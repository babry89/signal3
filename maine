Indicator Short Title
//@version=5
indicator(shorttitle="Pattern detection", title="Short signals", overlay=true)

Input Parameters

 length = input(10, title="sonnce Bar")
source = close
len = input(5, minval=1, title="look left bars for pattern")

length2 = input(3, minval=1, title="look left bars for trend confirmation")
length3 = input(14, minval=1, title="ATR calculation")
mult = input(2, minval=0, step=0.1, title="ATR multis")

Bullish Pattern Detection

patternBullish1 = ((low[len] > low[len+1]) and (high[len+2] > high[len+3]) and (high[len+4] > high[len+5]) and (high[len+4] > high[len+2]) and (low[len+4] < low[len+6]) and ((high[len+4] - low[len+4]) > (high[len+1] - low[len+1])*2))
patternBullish2 = ((low[len] > low[len+1]) and (high[len+2] > high[len+3]) and (high[len+4] > high[len+5]) and (low[len+4] > low[len+2]) and (close[len+4] > (high[len+2]+low[len+2])/2)) or
                  ((high[len] > high[len+1]) and (low[len+2] < low[len+3]) and (low[len+4] < low[len+5]) and (high[len+4] < high[len+6]) and ((high[len+4] - low[len+4]) > (high[len+1] - low[len+1])*2))
patternBullish3 = ((low[len] > low[len+1]) and (high[len+2] > high[len+3]) and (high[len+4] > high[len+5]) and (high[len+4] > high[len+2]) and (low[len+4] < low[len+6]) and (low[len+7] > low[len+4]) and ((high[len+4] - low[len+4]) > (high[len+1] - low[len+1])*2) and (low[len+4] > (high[len+2] + low[len+2])/2))

Bearish Pattern Detection

patternBearish1 = ((high[len] < high[len+1]) and (low[len+2] < low[len+3]) and (low[len+4] < low[len+5]) and (low[len+4] < low[len+2]) and (high[len+4] > high[len+6]) and ((high[len+4] - low[len+4]) > (high[len+1] - low[len+1])*2))
patternBearish2 = ((high[len] < high[len+1]) and (low[len+2] < low[len+3]) and (low[len+4] < low[len+5]) and (high[len+4] < low[len+2]) and (close[len+4] < (high[len+2]+low[len+2])/2)) or
                  ((low[len] < low[len+1]) and (high[len+2] > high[len+3]) and (high[len+4] > high[len+5]) and (low[len+4] > low[len+6]) and ((high[len+4] - low[len+4]) > (high[len+1] - low[len+1])*2))
patternBearish3 = ((high[len] < high[len+1]) and (low[len+2] < low[len+3]) and (low[len+4] < low[len+5]) and (low[len+4] < low[len+2]) and (high[len+4] > high[len+6]) and (high[len+7] < high[len+4]) and ((high[len+4] - low[len+4]) > (high[len+1] - low[len+1])*2) and (low[len+4] > (high[len+2] + low[len+2])/2))

Trend Confirmation

trendConf1 = ( Math.abs(close- Math.max(high[length2], low[length2])) <  Math.abs(high[length2]- low[length2]) )
trendConf2 = ( close >= ( high[length2] + low[length2] ) /2  )

Strength Condition

strengthCond1 = (volume > ta.sma(volume, length) * 2)
strengthCond2 = ( Math.abs(high - low) > ta.atr(high,length3) * mult)

Pattern Filter

patternFilter = ((patternBullish1 or patternBullish2 or patternBullish3) and (trendConf1 or trendConf2) and (strengthCond1 or strengthCond2))

Alert Conditions

if (patternFilter)
    alertcondition(true, title="Bullish Pattern", message="Bullish Pattern detected!")
if ( Math.abs(close - close[1]) > (high[1]-low[1]) *2 or close > ta.sma(close, length2)  )
    alertcondition(true, title="Support Level", message="Price bounced off the Support Level!")

// Plot Shape

plotshape(series=close, style=shape.labeldown, location=location.belowbar, title="Support Level")

// Plot Colors

p1 = color.new(color.blue, 0)
p2 = color.new(color.red, 0)

// Pattern Color

bp = color.rgb(34,139,34)
cp = color.rgb(25,25,112)

// ATR calc

atr = ta.atr(high, length3, low, mult)

// PLOT

plot(p1, title="Support", style=plot.style_cross, linewidth=1, color=color.rgb(23, 140, 7, 0))
plot(p2, title="Resistance", style=plot.style_cross, linewidth=1, color=color.rgb(229, 51, 6, 0))

hline(0, title="Zero Line", style=plot.style_cross, linewidth=2, color=color.rgb(218, 126, 3, 0))

// FILL PLOT

fill(h1, h2, title="Value Area High", color=color.rgb(90, 180, 200, 90))

// Hlong

hlong = input.string(title="Hlong Symbol", defval="AAPL", minval=0, maxval=10000000)

// Buy signal condtion

longCondition = ((close > high[1]) or (close > close[1] and high[1] < high[2]) or (close[1] < close[2] and high[1] > high[2]) or (close < low[1] and low[1] > low[2]))

// Strategy Management

strategy.entry("Buy", strategy.long, when=longCondition[1])

// Annotation

ta.annotation.new(bar_index, high, text="Buy", location=location.belowbar, color=color.green, style=la

//@version=5
indicator("RTM Supreme Strategy", shorttitle="RTM-SUPREME", overlay=true)

// Input parameters
var bool enableQM = input.bool(true, "Enable Quasimodo Pattern")
var bool enableBSZ = input.bool(true, "Enable BSZ Pattern") 
var bool enableOB = input.bool(true, "Enable Order Block")
var bool enableFVG = input.bool(true, "Enable Fair Value Gap")
var float minConfidence = input.float(0.7, "Minimum Pattern Confidence", 0.1, 1.0)
var float riskPerTrade = input.float(1.0, "Risk Per Trade %", 0.1, 5.0)

// Pattern detection functions
detectQuasimodo() =>
    bullQM = low[4] > low[2] and high[3] > high[1] and low[2] < low[0]
    bearQM = high[4] < high[2] and low[3] < low[1] and high[2] > high[0]
    [bullQM, bearQM]

detectBSZ() =>
    bszRange = high[5] - low[5]
    bszTop = high[5] + bszRange * 0.1
    bszBottom = low[5] - bszRange * 0.1
    bszBreakUp = close > bszTop and close[1] <= bszTop
    bszBreakDown = close < bszBottom and close[1] >= bszBottom
    [bszBreakUp, bszBreakDown]

detectOB() =>
    obSize = high - low
    obValid = obSize > ta.atr(14) * 1.5
    bullOB = obValid and close > open and volume > ta.sma(volume, 20)
    bearOB = obValid and close < open and volume > ta.sma(volume, 20)
    [bullOB, bearOB]

// Main logic
[bullQM, bearQM] = detectQuasimodo()
[bszBreakUp, bszBreakDown] = detectBSZ()
[bullOB, bearOB] = detectOB()

// Plot signals
plotshape(enableQM and bullQM, "Bullish QM", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(enableQM and bearQM, "Bearish QM", shape.triangledown, location.abovebar, color.red, size=size.small)

plotshape(enableBSZ and bszBreakUp, "BSZ Break Up", shape.triangleup, location.belowbar, color.blue, size=size.small)
plotshape(enableBSZ and bszBreakDown, "BSZ Break Down", shape.triangledown, location.abovebar, color.blue, size=size.small)

plotshape(enableOB and bullOB, "Bullish OB", shape.triangleup, location.belowbar, color.yellow, size=size.small)
plotshape(enableOB and bearOB, "Bearish OB", shape.triangledown, location.abovebar, color.yellow, size=size.small)

// Alerts
alertcondition(enableQM and bullQM, "Bullish Quasimodo", "Bullish QM Pattern Detected")
alertcondition(enableQM and bearQM, "Bearish Quasimodo", "Bearish QM Pattern Detected")
alertcondition(enableBSZ and (bszBreakUp or bszBreakDown), "BSZ Break", "BSZ Pattern Detected")
alertcondition(enableOB and (bullOB or bearOB), "Order Block", "Order Block Detected")

indicator("RTM Advanced Strategy", shorttitle="RTM_ADV", overlay=true)

// Input Parameters
timeframe = input.string("", "Timeframe", options=["", "1", "5", "15", "30", "60", "240", "D", "W", "M"])
enablePAZ = input.bool(true, "Enable PAZ Strategy")
enableQM = input.bool(true, "Enable Quasimodo Pattern")
enableBSZ = input.bool(true, "Enable BSZ Strategy")
enableOB = input.bool(true, "Enable Order Block")
enableFVG = input.bool(true, "Enable Fair Value Gap")
riskRatio = input.float(3.0, "Risk/Reward Ratio", minval=1.0)

// Function to detect swing highs/lows
isSwingHigh(len) =>
    high[len] > high[len + 1] and high[len] > high[len - 1]
    
isSwingLow(len) =>
    low[len] < low[len + 1] and low[len] < low[len - 1]

// Function to detect Engulfing patterns
bullishEngulfing() =>
    close > open[1] and open < close[1] and close - open > close[1] - open[1]
    
bearishEngulfing() =>
    open > close[1] and close < open[1] and open - close > open[1] - close[1]

// PAZ Strategy
var float[] pazLevels = array.new_float(0)
if enablePAZ
    if isSwingHigh(2)
        array.push(pazLevels, high[2])
    if isSwingLow(2)
        array.push(pazLevels, low[2])
    
    if array.size(pazLevels) > 0
        for i = 0 to array.size(pazLevels) - 1
            level = array.get(pazLevels, i)
            line.new(bar_index[2], level, bar_index, level, color=color.blue, style=line.style_dashed)

// Quasimodo Pattern Detection
var float qmLevel = na
if enableQM
    // QM Bullish
    qmBullish = low[4] > low[2] and high[3] > high[1] and low[2] < low[0]
    if qmBullish
        qmLevel := high[3]
        label.new(bar_index[3], high[3], "QM", color=color.green)
    
    // QM Bearish
    qmBearish = high[4] < high[2] and low[3] < low[1] and high[2] > high[0]
    if qmBearish
        qmLevel := low[3]
        label.new(bar_index[3], low[3], "QM", color=color.red)

// BSZ Strategy
if enableBSZ
    bszRange = high[5] - low[5]
    bszTop = high[5] + bszRange * 0.1
    bszBottom = low[5] - bszRange * 0.1
    
    // Draw BSZ
    box.new(bar_index[5], bszTop, bar_index, bszBottom, bgcolor=color.new(color.blue, 90))
    
    // BSZ Break Detection
    bszBreakUp = close > bszTop and close[1] <= bszTop
    bszBreakDown = close < bszBottom and close[1] >= bszBottom
    
    if bszBreakUp
        label.new(bar_index, high, "BSZ Break ↑", color=color.green)
    if bszBreakDown
        label.new(bar_index, low, "BSZ Break ↓", color=color.red)

// Order Block Detection
if enableOB
    obSize = high - low
    obValid = obSize > ta.atr(14) * 1.5
    
    if obValid and bullishEngulfing()
        box.new(bar_index-1, high, bar_index, low, bgcolor=color.new(color.green, 90))
        label.new(bar_index, high, "OB Buy", color=color.green)
        
    if obValid and bearishEngulfing()
        box.new(bar_index-1, high, bar_index, low, bgcolor=color.new(color.red, 90))
        label.new(bar_index, low, "OB Sell", color=color.red)

// Fair Value Gap Detection
if enableFVG
    fvgUp = low[2] > high[0] 
    fvgDown = high[2] < low[0]
    
    if fvgUp
        box.new(bar_index-2, low[2], bar_index, high[0], bgcolor=color.new(color.green, 90))
        label.new(bar_index, high, "FVG ↑", color=color.green)
        
    if fvgDown
        box.new(bar_index-2, high[2], bar_index, low[0], bgcolor=color.new(color.red, 90))
        label.new(bar_index, low, "FVG ↓", color=color.red)

// Combined Strategy Alerts
alertcondition(bszBreakUp and qmLevel != na and close > qmLevel, "Strong Buy Signal", "BSZ Break + QM Level")
alertcondition(bszBreakDown and qmLevel != na and close < qmLevel, "Strong Sell Signal", "BSZ Break + QM Level")
alertcondition(fvgUp and bullishEngulfing(), "FVG Buy Signal", "FVG + Bullish Engulfing")
alertcondition(fvgDown and bearishEngulfing(), "FVG Sell Signal", "FVG + Bearish Engulfing")

// Plot signals on chart
plotshape(bszBreakUp and qmLevel != na and close > qmLevel, "Buy", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(bszBreakDown and qmLevel != na and close < qmLevel, "Sell", shape.triangledown, location.abovebar, color.red, size=size.small)
// Risk Management and Position Sizing
calcPositionSize(entryPrice, stopPrice) =>
    riskAmount = math.abs(entryPrice - stopPrice)
    posSize = riskAmount * riskRatio
    posSize

// Advanced RTM Strategy Logic
var float lastSwingHigh = na
var float lastSwingLow = na
var float entryPrice = na
var float stopLoss = na
var float takeProfit = na

// Update swing levels
if isSwingHigh(2)
    lastSwingHigh := high[2]
if isSwingLow(2)
    lastSwingLow := low[2]

// Strategy Entry Conditions
longCondition = bszBreakUp and qmLevel != na and close > qmLevel and fvgUp
shortCondition = bszBreakDown and qmLevel != na and close < qmLevel and fvgDown

// Entry logic
if longCondition
    entryPrice := close
    stopLoss := math.min(lastSwingLow, low[1])
    takeProfit := entryPrice + (entryPrice - stopLoss) * riskRatio
    posSize = calcPositionSize(entryPrice, stopLoss)
    
    label.new(bar_index, low, "LONG\nEntry: " + str.tostring(entryPrice) + 
              "\nStop: " + str.tostring(stopLoss) + 
              "\nTP: " + str.tostring(takeProfit), 
              color=color.green)

if shortCondition
    entryPrice := close
    stopLoss := math.max(lastSwingHigh, high[1])
    takeProfit := entryPrice - (stopLoss - entryPrice) * riskRatio
    posSize = calcPositionSize(entryPrice, stopLoss)
    
    label.new(bar_index, high, "SHORT\nEntry: " + str.tostring(entryPrice) + 
              "\nStop: " + str.tostring(stopLoss) + 
              "\nTP: " + str.tostring(takeProfit), 
              color=color.red)

// Draw trade levels
if not na(entryPrice)
    line.new(bar_index[1], entryPrice, bar_index, entryPrice, 
             color=longCondition ? color.green : color.red)
    line.new(bar_index[1], stopLoss, bar_index, stopLoss, 
             color=color.red, style=line.style_dashed)
    line.new(bar_index[1], takeProfit, bar_index, takeProfit, 
             color=color.green, style=line.style_dashed)

// Performance stats
var float totalTrades = 0
var float winningTrades = 0
var float losingTrades = 0

if longCondition or shortCondition
    totalTrades := totalTrades + 1
    
    if (longCondition and close > takeProfit) or 
       (shortCondition and close < takeProfit)
        winningTrades := winningTrades + 1
    if (longCondition and close < stopLoss) or 
       (shortCondition and close > stopLoss)
        losingTrades := losingTrades + 1

// Display stats
var table statsTable = table.new(position.top_right, 2, 4)
table.cell(statsTable, 0, 0, "Total Trades", bgcolor=color.new(color.blue, 90))
table.cell(statsTable, 1, 0, str.tostring(totalTrades), bgcolor=color.new(color.blue, 90))
table.cell(statsTable, 0, 1, "Win Rate", bgcolor=color.new(color.green, 90))
table.cell(statsTable, 1, 1, str.tostring(winningTrades/totalTrades*100) + "%", 
           bgcolor=color.new(color.green, 90))
table.cell(statsTable, 0, 2, "Profit Factor", bgcolor=color.new(color.yellow, 90))
table.cell(statsTable, 1, 2, str.tostring((winningTrades*riskRatio)/losingTrades), 
           bgcolor=color.new(color.yellow, 90))

// Export signals
alertcondition(longCondition, "RTM Long Entry", 
               "Long Entry at {{close}}, Stop: {{plot('stopLoss')}}, TP: {{plot('takeProfit')}}")
alertcondition(shortCondition, "RTM Short Entry", 
               "Short Entry at {{close}}, Stop: {{plot('stopLoss')}}, TP: {{plot('takeProfit')}}")
            // CTF Strategy - Critical Time Frame Strategy
            ctfValue = input(14, "CTF Period")
            ctfSignal = ta.sma(close, ctfValue)

            // Market Structure Strategy
            msHigh = ta.highest(high, ctfValue) 
            msLow = ta.lowest(low, ctfValue)
            msDirection = close > msHigh ? 1 : close < msLow ? -1 : 0

            // Order Flow Strategy 
            ofVolume = volume * (close - open)
            ofAccumulation = ta.sum(ofVolume, ctfValue)
            ofSignal = ofAccumulation > 0 ? 1 : -1

            // Combined Strategy Signal
            combinedSignal = msDirection * ofSignal

            // Draw signals
            plotshape(combinedSignal == 1, "Buy Signal", shape.triangleup, location.belowbar, color.green)
            plotshape(combinedSignal == -1, "Sell Signal", shape.triangledown, location.abovebar, color.red)

            // Monitor open positions
            var float entryPrice = na
            var float stopLoss = na
            var float takeProfit = na
            var int positionType = 0 // 1 for long, -1 for short

            // Position Management
            if combinedSignal == 1 and positionType == 0
                positionType := 1
                entryPrice := close  
                stopLoss := low - ta.atr(14)
                takeProfit := entryPrice + (entryPrice - stopLoss) * riskRatio

            if combinedSignal == -1 and positionType == 0  
                positionType := -1
                entryPrice := close
                stopLoss := high + ta.atr(14)  
                takeProfit := entryPrice - (stopLoss - entryPrice) * riskRatio

            // Exit signals
            if positionType == 1 and (high >= takeProfit or low <= stopLoss)
                positionType := 0
                entryPrice := na
                stopLoss := na
                takeProfit := na

            if positionType == -1 and (low <= takeProfit or high >= stopLoss)
                positionType := 0
                entryPrice := na
                stopLoss := na
                takeProfit := na

            // Draw position info
            if not na(entryPrice)
                line.new(bar_index[1], entryPrice, bar_index, entryPrice, color=positionType==1 ? color.green : color.red)
                line.new(bar_index[1], stopLoss, bar_index, stopLoss, color=color.red, style=line.style_dashed)
                line.new(bar_index[1], takeProfit, bar_index, takeProfit, color=color.green, style=line.style_dashed)

            // Advanced alerts
            alertcondition(combinedSignal == 1, "Strong Buy Setup", 
                "Multiple strategy confluence suggesting long entry")
            alertcondition(combinedSignal == -1, "Strong Sell Setup",
                "Multiple strategy confluence suggesting short entry")

            // Risk Management Table
            var table riskTable = table.new(position.bottom_right, 2, 4, border_width=1)
            if barstate.islast
                table.cell(riskTable, 0, 0, "Position Type", bgcolor=color.new(color.blue, 90))
                table.cell(riskTable, 1, 0, positionType==1 ? "LONG" : positionType==-1 ? "SHORT" : "FLAT", 
                    bgcolor=color.new(positionType==1 ? color.green : positionType==-1 ? color.red : color.gray, 90))
                table.cell(riskTable, 0, 1, "Entry Price", bgcolor=color.new(color.blue, 90))
                table.cell(riskTable, 1, 1, not na(entryPrice) ? str.tostring(entryPrice) : "-", 
                    bgcolor=color.new(color.blue, 90))
                table.cell(riskTable, 0, 2, "Stop Loss", bgcolor=color.new(color.red, 90))
                table.cell(riskTable, 1, 2, not na(stopLoss) ? str.tostring(stopLoss) : "-",
                    bgcolor=color.new(color.red, 90))
                table.cell(riskTable, 0, 3, "Take Profit", bgcolor=color.new(color.green, 90))
                table.cell(riskTable, 1, 3, not na(takeProfit) ? str.tostring(takeProfit) : "-",
                    bgcolor=color.new(color.green, 90))
                    // Advanced Smart Money Strategy Integration
                    strategySmartMoney(string source = "close") =>
                        var float[] historicalPrices = array.new_float(0)
                        array.push(historicalPrices, source)
                        
                        // Smart Pattern Detection
                        var patternData = {
                            "QM": false,
                            "BSZ": false,
                            "OB": false,
                            "FVG": false,
                            "PA": false
                        }
                        
                        // Dynamic Pattern Scanner
                        scanPatterns() =>
                            patternFound = false
                            
                            // QM Pattern
                            if (isQuasimodoBullish() or isQuasimodoBearish())
                                patternData.QM := true
                                patternFound := true
                                
                            // BSZ Pattern    
                            if (isBreakoutStopZone())
                                patternData.BSZ := true
                                patternFound := true
                                
                            // Order Block
                            if (isOrderBlock())
                                patternData.OB := true
                                patternFound := true
                                
                            // Fair Value Gap
                            if (isFairValueGap())
                                patternData.FVG := true
                                patternFound := true
                                
                            // Price Action
                            if (isPriceActionSetup())
                                patternData.PA := true
                                patternFound := true
                                
                            patternFound

                        // AI-Based Pattern Strength Analysis
                        patternStrength = 0.0
                        if (patternData.QM)
                            patternStrength += 0.3
                        if (patternData.BSZ)
                            patternStrength += 0.25
                        if (patternData.OB)
                            patternStrength += 0.2
                        if (patternData.FVG)
                            patternStrength += 0.15
                        if (patternData.PA)
                            patternStrength += 0.1
                            
                        // Dynamic Risk Management
                        riskLevel = input.float(1.0, "Risk Level (%)", 0.1, 5.0)
                        var positionSize = 0.0
                        
                        if (patternStrength >= 0.7)  // High probability setup
                            positionSize := riskLevel * 1.5
                        else if (patternStrength >= 0.5)  // Medium probability
                            positionSize := riskLevel
                        else if (patternStrength >= 0.3)  // Lower probability
                            positionSize := riskLevel * 0.5
                            
                        // Smart Money Alerts
                        alertCondition = patternStrength >= input.float(0.5, "Alert Threshold", 0.1, 1.0)
                        if (alertCondition)
                            alert("Smart Money Setup Detected! Strength: " + str.tostring(patternStrength), alert.freq_once_per_bar)
                            
                        // Pattern Visualization
                        var table smartMoneyTable = table.new(position.top_right, columns=2, rows=6, bgcolor=color.black, border_width=1)
                        if barstate.islast
                            table.cell(smartMoneyTable, 0, 0, "Pattern Analysis", bgcolor=color.new(color.blue, 90))
                            table.cell(smartMoneyTable, 0, 1, "QM Pattern", bgcolor=patternData.QM ? color.green : color.gray)
                            table.cell(smartMoneyTable, 0, 2, "BSZ Pattern", bgcolor=patternData.BSZ ? color.green : color.gray)
                            table.cell(smartMoneyTable, 0, 3, "Order Block", bgcolor=patternData.OB ? color.green : color.gray)
                            table.cell(smartMoneyTable, 0, 4, "FVG", bgcolor=patternData.FVG ? color.green : color.gray)
                            table.cell(smartMoneyTable, 0, 5, "Price Action", bgcolor=patternData.PA ? color.green : color.gray)
                            
                        // Return strategy components
                        [patternStrength, positionSize, alertCondition]

                    // Adaptive Smart Money Implementation
                    [strength, position, alert] = strategySmartMoney(close)

                    // Create combined strategy signal
                    var combinedSignal = 0
                    if (strength >= 0.7 and longCondition)
                        combinedSignal := 1
                    else if (strength >= 0.7 and shortCondition)
                        combinedSignal := -1
                    else
                        combinedSignal := 0

                    // Plot combined signals
                    plotshape(combinedSignal == 1, "Strong Buy", shape.triangleup, location.belowbar, color.green, size=size.large)
                    plotshape(combinedSignal == -1, "Strong Sell", shape.triangledown, location.abovebar, color.red, size=size.large)

                    // Additional visualization
                    var label signalLabel = na
                    if (alert)
                        signalLabel := label.new(bar_index, high, 
                            text="Smart Money Setup\nStrength: " + str.tostring(strength, "#.##") + 
                            "\nPosition Size: " + str.tostring(position, "#.##"),
                            color=combinedSignal == 1 ? color.green : color.red,
                            style=label.style_label_down,
                            textcolor=color.white)

                    // Strategy performance monitoring
                    var float totalProfit = 0.0
                    var float maxDrawdown = 0.0
                    var float winRate = 0.0

                    // Update performance metrics
                    if (barstate.islast)
                        // Calculate metrics based on historical trades
                        totalProfit := calcTotalProfit()
                        maxDrawdown := calcMaxDrawdown()
                        winRate := calcWinRate()
                        
                        // Display performance metrics
                        var table performanceTable = table.new(position.bottom_right, columns=2, rows=3)
                        table.cell(performanceTable, 0, 0, "Total Profit", bgcolor=color.new(color.blue, 90))
                        table.cell(performanceTable, 1, 0, str.tostring(totalProfit), bgcolor=color.new(totalProfit >= 0 ? color.green : color.red, 90))
                        table.cell(performanceTable, 0, 1, "Max Drawdown", bgcolor=color.new(color.blue, 90))
                        table.cell(performanceTable, 1, 1, str.tostring(maxDrawdown), bgcolor=color.new(color.red, 90))
                        table.cell(performanceTable, 0, 2, "Win Rate", bgcolor=color.new(color.blue, 90))
                        table.cell(performanceTable, 1, 2, str.tostring(winRate) + "%", bgcolor=color.new(color.green, 90))

                    // Export strategy data
                    if (barstate.islast)
                        var string strategyData = "Smart Money Strategy Analysis:\n" +
                            "Pattern Strength: " + str.tostring(strength) + "\n" +
                            "Position Size: " + str.tostring(position) + "\n" +
                            "Total Profit: " + str.tostring(totalProfit) + "\n" +
                            "Max Drawdown: " + str.tostring(maxDrawdown) + "\n" +
                            "Win Rate: " + str.tostring(winRate) + "%"
                        
                        alert(strategyData, alert.freq_once_per_bar)
                        // Advanced Smart Money Strategy Integration (continued)

                        // Helper functions for pattern detection
                        isQuasimodoBullish() =>
                            len = 5
                            swingLow1 = low[len] < low[len-1] and low[len] < low[len+1]
                            swingHigh = high[len-2] > high[len-3] and high[len-2] > high[len-1]
                            swingLow2 = low[len-4] > low[len-3] and low[len-4] > low[len-5]
                            swingLow1 and swingHigh and swingLow2

                        isQuasimodoBearish() =>
                            len = 5
                            swingHigh1 = high[len] > high[len-1] and high[len] > high[len+1]
                            swingLow = low[len-2] < low[len-3] and low[len-2] < low[len-1]
                            swingHigh2 = high[len-4] < high[len-3] and high[len-4] < high[len-5]
                            swingHigh1 and swingLow and swingHigh2

                        isBreakoutStopZone() =>
                            bszRange = high[5] - low[5]
                            bszTop = high[5] + bszRange * 0.1
                            bszBottom = low[5] - bszRange * 0.1
                            bszBreakUp = close > bszTop and close[1] <= bszTop
                            bszBreakDown = close < bszBottom and close[1] >= bszBottom
                            bszBreakUp or bszBreakDown

                        isOrderBlock() =>
                            obSize = high - low
                            obValid = obSize > ta.atr(14) * 1.5
                            bullishEngulfing = close > open[1] and open < close[1] and close - open > close[1] - open[1]
                            bearishEngulfing = open > close[1] and close < open[1] and open - close > open[1] - close[1]
                            obValid and (bullishEngulfing or bearishEngulfing)

                        isFairValueGap() =>
                            fvgUp = low[2] > high[0]
                            fvgDown = high[2] < low[0]
                            fvgUp or fvgDown

                        isPriceActionSetup() =>
                            engulfing = bullishEngulfing() or bearishEngulfing()
                            pinBar = math.abs(close - open) <= (high - low) * 0.3 and ((high - math.max(close, open)) > math.abs(close - open) * 2 or (math.min(close, open) - low) > math.abs(close - open) * 2)
                            engulfing or pinBar

                        // Performance calculation functions
                        calcTotalProfit() =>
                            var float profit = 0.0
                            if combinedSignal[1] != 0
                                if combinedSignal[1] == 1
                                    profit += (close - close[1])/close[1] * 100
                                else
                                    profit += (close[1] - close)/close[1] * 100
                            profit

                        calcMaxDrawdown() =>
                            var float maxPrice = high
                            var float maxDrawdown = 0.0
                            if high > maxPrice
                                maxPrice := high
                            currentDrawdown = (maxPrice - low)/maxPrice * 100
                            if currentDrawdown > maxDrawdown
                                maxDrawdown := currentDrawdown
                            maxDrawdown

                        calcWinRate() =>
                            var int totalTrades = 0
                            var int winningTrades = 0
                            if combinedSignal[1] != 0
                                totalTrades += 1
                                if (combinedSignal[1] == 1 and close > close[1]) or (combinedSignal[1] == -1 and close < close[1])
                                    winningTrades += 1
                            totalTrades > 0 ? (winningTrades/totalTrades) * 100 : 0.0

                        // Smart Alerts System
                        var alertsEnabled = input.bool(true, "Enable Smart Alerts")
                        var minimumSignalStrength = input.float(0.7, "Minimum Signal Strength", 0.1, 1.0)

                        if alertsEnabled and strength >= minimumSignalStrength
                            if combinedSignal == 1
                                alert("Strong Buy Signal Detected\nStrength: " + str.tostring(strength) + 
                                      "\nPattern Confluence:\n" +
                                      (patternData.QM ? "- Quasimodo Pattern\n" : "") +
                                      (patternData.BSZ ? "- BSZ Pattern\n" : "") +
                                      (patternData.OB ? "- Order Block\n" : "") +
                                      (patternData.FVG ? "- Fair Value Gap\n" : "") +
                                      (patternData.PA ? "- Price Action Setup\n" : "") +
                                      "Suggested Position Size: " + str.tostring(position))
                                      
                            if combinedSignal == -1
                                alert("Strong Sell Signal Detected\nStrength: " + str.tostring(strength) + 
                                      "\nPattern Confluence:\n" +
                                      (patternData.QM ? "- Quasimodo Pattern\n" : "") +
                                      (patternData.BSZ ? "- BSZ Pattern\n" : "") +
                                      (patternData.OB ? "- Order Block\n" : "") +
                                      (patternData.FVG ? "- Fair Value Gap\n" : "") +
                                      (patternData.PA ? "- Price Action Setup\n" : "") +
                                      "Suggested Position Size: " + str.tostring(position))

                        // Dynamic Pattern Scanner with Auto-Detection
                        var patternScanner = array.new_string(0)
                        if barstate.islast
                            array.clear(patternScanner)
                            
                            // Scan for all potential patterns
                            if patternData.QM
                                array.push(patternScanner, "Quasimodo Pattern")
                            if patternData.BSZ
                                array.push(patternScanner, "BSZ Pattern")
                            if patternData.OB
                                array.push(patternScanner, "Order Block")
                            if patternData.FVG
                                array.push(patternScanner, "Fair Value Gap")
                            if patternData.PA
                                array.push(patternScanner, "Price Action Setup")
                            
                            // Display active patterns
                            if array.size(patternScanner) > 0
                                var table patternTable = table.new(position.bottom_left, array.size(patternScanner), 2)
                                for i = 0 to array.size(patternScanner) - 1
                                    table.cell(patternTable, 0, i, array.get(patternScanner, i), 
                                              bgcolor=color.new(color.blue, 90))
                                    table.cell(patternTable, 1, i, "Active", 
                                              bgcolor=color.new(color.green, 90))

                        // Export strategy settings
                        if barstate.islast
                            var string exportData = 
                                "RTM Advanced Strategy Settings:\n" +
                                "Timeframe: " + timeframe + "\n" +
                                "PAZ Strategy: " + (enablePAZ ? "Enabled" : "Disabled") + "\n" +
                                "Quasimodo Pattern: " + (enableQM ? "Enabled" : "Disabled") + "\n" +
                                "BSZ Strategy: " + (enableBSZ ? "Enabled" : "Disabled") + "\n" +
                                "Order Block: " + (enableOB ? "Enabled" : "Disabled") + "\n" +
                                "Fair Value Gap: " + (enableFVG ? "Enabled" : "Disabled") + "\n" +
                                "Risk/Reward Ratio: " + str.tostring(riskRatio) + "\n" +
                                "Current Pattern Strength: " + str.tostring(strength) + "\n" +
                                "Suggested Position Size: " + str.tostring(position) + "\n" +
                                "Performance Metrics:\n" +
                                "Total Profit: " + str.tostring(totalProfit) + "%\n" +
                                "Max Drawdown: " + str.tostring(maxDrawdown) + "%\n" +
                                "Win Rate: " + str.tostring(winRate) + "%"
                            
                            alert(exportData, alert.freq_once_per_bar_close)
                            // Dynamic Strategy Manager
                            strategyManager() =>
                                var settings = {
                                    "useML": input.bool(true, "Use Machine Learning"),
                                    "autoDetect": input.bool(true, "Auto Detect Patterns"),
                                    "adaptiveRisk": input.bool(true, "Adaptive Risk Management"),
                                    "multiTimeframe": input.bool(true, "Multi-Timeframe Analysis"),
                                    "patternConfluence": input.float(0.7, "Pattern Confluence Threshold", 0.1, 1.0),
                                    "maxRiskPerTrade": input.float(2.0, "Maximum Risk Per Trade (%)", 0.1, 5.0),
                                    "minConfidence": input.float(0.8, "Minimum Confidence Score", 0.5, 1.0)
                                }

                                // Pattern Recognition Engine
                                var patternEngine = {
                                    "patterns": array.new_string(0),
                                    "confidence": array.new_float(0),
                                    "signals": array.new_int(0)
                                }

                                // Multi-Timeframe Analysis
                                mtfAnalysis() =>
                                    timeframes = array.from("1", "5", "15", "30", "60", "240", "D", "W")
                                    var mtfSignals = array.new_int(0)
                                    
                                    for timeframe in timeframes
                                        security(syminfo.tickerid, timeframe, close)
                                        if settings.multiTimeframe
                                            array.push(mtfSignals, scanPatterns())
                                    
                                    mtfSignals

                                // AI-Based Pattern Detection
                                aiPatternDetection() =>
                                    if settings.useML
                                        // Advanced pattern recognition using ML techniques
                                        features = array.new_float(0)
                                        array.push(features, ta.rsi(close, 14))
                                        array.push(features, ta.macd(close, 12, 26, 9)[1])
                                        array.push(features, ta.stoch(close, high, low, 14)[1])
                                        
                                        // Calculate pattern probability using ML model
                                        probability = mlModel(features)
                                        [probability >= settings.minConfidence, probability]
                                    else
                                        [false, 0.0]

                                // Adaptive Risk Management
                                adaptiveRiskManagement(confidence) =>
                                    if settings.adaptiveRisk
                                        baseRisk = settings.maxRiskPerTrade
                                        adjustedRisk = baseRisk * confidence
                                        math.min(adjustedRisk, settings.maxRiskPerTrade)
                                    else
                                        settings.maxRiskPerTrade

                                // Smart Alert System
                                smartAlerts(patterns, confidence) =>
                                    if array.size(patterns) > 0
                                        for i = 0 to array.size(patterns) - 1
                                            pattern = array.get(patterns, i)
                                            conf = array.get(confidence, i)
                                            if conf >= settings.minConfidence
                                                alert("Pattern Detected: " + pattern + "\nConfidence: " + str.tostring(conf))

                                // Pattern Confluence Analysis
                                confluenceAnalysis() =>
                                    patterns = patternEngine.patterns
                                    confidence = patternEngine.confidence
                                    signals = patternEngine.signals
                                    
                                    totalConfluence = 0.0
                                    if array.size(patterns) > 0
                                        for i = 0 to array.size(patterns) - 1
                                            totalConfluence += array.get(confidence, i)
                                        
                                    avgConfluence = totalConfluence / array.size(patterns)
                                    avgConfluence >= settings.patternConfluence

                                // Auto Pattern Detection
                                if settings.autoDetect
                                    // Scan for all pattern types
                                    qm = detectQuasimodo()
                                    bsz = detectBSZ()
                                    ob = detectOrderBlock()
                                    fvg = detectFairValueGap()
                                    paz = detectPAZ()
                                    
                                    if qm[0]
                                        array.push(patternEngine.patterns, "Quasimodo")
                                        array.push(patternEngine.confidence, qm[1])
                                        array.push(patternEngine.signals, qm[2])
                                        
                                    if bsz[0]
                                        array.push(patternEngine.patterns, "BSZ")
                                        array.push(patternEngine.confidence, bsz[1])
                                        array.push(patternEngine.signals, bsz[2])
                                        
                                    // Similar for other patterns...

                                // Process signals and generate alerts
                                mtfSignals = mtfAnalysis()
                                [aiValid, aiConfidence] = aiPatternDetection()
                                
                                if confluenceAnalysis() and aiValid
                                    risk = adaptiveRiskManagement(aiConfidence)
                                    smartAlerts(patternEngine.patterns, patternEngine.confidence)
                                    
                                    // Return strategy signals
                                    [patternEngine.signals, risk, aiConfidence]
                                else
                                    [array.new_int(0), 0.0, 0.0]

                            // Execute Strategy Manager
                            [signals, risk, confidence] = strategyManager()

                            // Plot results on chart
                            if array.size(signals) > 0
                                for i = 0 to array.size(signals) - 1
                                    signal = array.get(signals, i)
                                    if signal == 1
                                        plotshape(series=true, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.normal)
                                    else if signal == -1
                                        plotshape(series=true, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.normal)

                            // Display strategy information
                            var table infoTable = table.new(position.top_right, 3, 5)
                            if barstate.islast
                                table.cell(infoTable, 0, 0, "Strategy Status", bgcolor=color.new(color.blue, 90))
                                table.cell(infoTable, 1, 0, "Active Patterns", bgcolor=color.new(color.blue, 90))
                                table.cell(infoTable, 2, 0, str.tostring(array.size(signals)), bgcolor=color.new(color.blue, 90))
                                table.cell(infoTable, 0, 1, "Confidence", bgcolor=color.new(color.green, 90))
                                table.cell(infoTable, 1, 1, str.tostring(confidence), bgcolor=color.new(color.green, 90))
                                table.cell(infoTable, 0, 2, "Risk Level", bgcolor=color.new(color.red, 90))
                                table.cell(infoTable, 1, 2, str.tostring(risk) + "%", bgcolor=color.new(color.red, 90))
                                # Advanced Pattern Recognition and Signal Generation
                                def smartPatternDetector():
                                    # Initialize pattern arrays
                                    patterns = []
                                    signals = []
                                    confidences = []

                                    # Scan for all pattern types
                                    for pattern in ["QM", "BSZ", "OB", "FVG", "PAZ", "3D"]:
                                        if isPatternForming(pattern):
                                            patterns.append(pattern)
                                            signals.append(getPatternSignal(pattern))
                                            confidences.append(calculateConfidence(pattern))

                                    # Return combined results
                                    return patterns, signals, confidences

                                def isPatternForming(patternType):
                                    if patternType == "QM":
                                        # Quasimodo pattern detection
                                        bullishQM = low[4] > low[2] and high[3] > high[1] and low[2] < low[0]
                                        bearishQM = high[4] < high[2] and low[3] < low[1] and high[2] > high[0]
                                        return bullishQM or bearishQM
                                    
                                    elif patternType == "BSZ":
                                        # BSZ pattern detection  
                                        bszRange = high[5] - low[5]
                                        bszTop = high[5] + bszRange * 0.1
                                        bszBottom = low[5] - bszRange * 0.1
                                        return close > bszTop or close < bszBottom

                                    elif patternType == "OB":
                                        # Order block detection
                                        obSize = high - low
                                        return obSize > atr(14) * 1.5

                                    elif patternType == "FVG":
                                        # Fair value gap detection
                                        return (low[2] > high[0]) or (high[2] < low[0])

                                    elif patternType == "PAZ": 
                                        # Price action zone detection
                                        return isSwingHigh(2) or isSwingLow(2)

                                    elif patternType == "3D":
                                        # Three drive pattern detection
                                        return isThreeDrivePattern()

                                def calculateConfidence(pattern):
                                    confidence = 0.0
                                    
                                    # Base confidence from pattern type
                                    patternWeights = {
                                        "QM": 0.3,
                                        "BSZ": 0.25,
                                        "OB": 0.2,
                                        "FVG": 0.15,
                                        "PAZ": 0.1,
                                        "3D": 0.2
                                    }
                                    
                                    confidence += patternWeights[pattern]
                                    
                                    # Add volume confirmation
                                    if volume > sma(volume, 20):
                                        confidence += 0.1
                                        
                                    # Add trend confirmation
                                    if close > sma(close, 200):
                                        confidence += 0.1
                                    
                                    # Add volatility confirmation
                                    if atr(14) > sma(atr(14), 20):
                                        confidence += 0.1
                                        
                                    return confidence

                                def getPatternSignal(pattern):
                                    signal = 0
                                    
                                    if pattern == "QM":
                                        # Quasimodo pattern signal
                                        signal = 1 if isQuasimodoBullish() else -1
                                        
                                    elif pattern == "BSZ":
                                        # BSZ pattern signal
                                        signal = 1 if close > high[5] else -1
                                        
                                    elif pattern == "OB":
                                        # Order block signal
                                        signal = 1 if close > open else -1
                                        
                                    elif pattern == "FVG":
                                        # Fair value gap signal  
                                        signal = 1 if low[2] > high[0] else -1
                                        
                                    elif pattern == "PAZ":
                                        # Price action zone signal
                                        signal = 1 if isSwingLow(2) else -1
                                        
                                    elif pattern == "3D":
                                        # Three drive pattern signal
                                        signal = getThreeDriveSignal()
                                        
                                    return signal

                                # Advanced Alert System
                                def smartAlertSystem(patterns, signals, confidences):
                                    for i in range(len(patterns)):
                                        if confidences[i] >= 0.7:  # High confidence threshold
                                            message = f"""
                                            Pattern: {patterns[i]}
                                            Signal: {'BUY' if signals[i]==1 else 'SELL'}
                                            Confidence: {confidences[i]:.2f}
                                            Price: {close}
                                            Time: {time}
                                            """
                                            alert(message)

                                # Pattern Scanner Table
                                def displayPatternTable(patterns, confidences):
                                    table.clear(patternTable)
                                    table.cell(patternTable, 0, 0, "Pattern Type", bgcolor=color.blue)
                                    table.cell(patternTable, 1, 0, "Confidence", bgcolor=color.blue)
                                    
                                    for i in range(len(patterns)):
                                        table.cell(patternTable, 0, i+1, patterns[i])
                                        table.cell(patternTable, 1, i+1, str(confidences[i]))

                                # Main Strategy Loop
                                if barstate.islast:
                                    # Detect patterns
                                    patterns, signals, confidences = smartPatternDetector()
                                    
                                    # Generate alerts
                                    smartAlertSystem(patterns, signals, confidences)
                                    
                                    # Update pattern table
                                    displayPatternTable(patterns, confidences)
                                    
                                    # Plot signals on chart
                                    for i in range(len(signals)):
                                        if signals[i] == 1:
                                            plotshape(true, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small)
                                        elif signals[i] == -1:
                                            plotshape(true, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small)

                                # Risk Management Panel
                                riskPanel = input.float(1.0, "Risk per trade (%)", minval=0.1, maxval=5.0)
                                positionSize = (equity * (riskPanel/100)) / (atr(14) * syminfo.pointvalue)

                                # Update Risk Table
                                if barstate.islast:
                                    table.cell(riskTable, 0, 0, "Position Size", bgcolor=color.new(color.blue, 90))
                                    table.cell(riskTable, 1, 0, str(positionSize), bgcolor=color.new(color.blue, 90))
                                    # Additional utility functions for pattern detection
                                    def detectThreeDrivePattern():
                                        # Initialize arrays
                                        drives = []
                                        retracements = []
                                        
                                        # Scan last N candles
                                        for i in range(len(close)-20, len(close)):
                                            if close[i] > open[i] and close[i] > close[i-1]:
                                                drives.append(i)
                                            elif close[i] < open[i] and close[i] < close[i-1]: 
                                                retracements.append(i)
                                                
                                        # Check for valid 3-drive pattern
                                        if len(drives) >= 3 and len(retracements) >= 2:
                                            # Validate measurements
                                            drive1 = high[drives[0]] - low[retracements[0]]
                                            drive2 = high[drives[1]] - low[retracements[1]] 
                                            drive3 = high[drives[2]] - low[retracements[1]]
                                            
                                            # Check for symmetry
                                            if abs(drive1/drive2 - 1.0) < 0.1 and abs(drive2/drive3 - 1.0) < 0.1:
                                                return True
                                                
                                        return False

                                    def detectCompression():
                                        # Calculate Bollinger Bands
                                        middle = sma(close, 20)
                                        upper = middle + stdev(close, 20) * 2
                                        lower = middle - stdev(close, 20) * 2
                                        
                                        # Check for compression
                                        bw = (upper - lower) / middle
                                        bw_sma = sma(bw, 20)
                                        
                                        if bw < bw_sma * 0.8:
                                            return True
                                        return False

                                    def detectLiquidityVoid():
                                        # Check for large gaps in price
                                        voidSize = 2 * atr(14)
                                        
                                        if low[1] - high[2] > voidSize or low[2] - high[1] > voidSize:
                                            return True
                                        return False

                                    # Smart Signals Class
                                    class SmartSignals:
                                        def __init__(self):
                                            self.patterns = []
                                            self.signals = []
                                            self.confidences = []
                                            self.alerts = []
                                            
                                        def addPattern(self, pattern, signal, confidence):
                                            self.patterns.append(pattern)
                                            self.signals.append(signal)
                                            self.confidences.append(confidence)
                                            
                                            if confidence > 0.7:
                                                self.alerts.append({
                                                    'pattern': pattern,
                                                    'signal': signal,
                                                    'confidence': confidence,
                                                    'price': close,
                                                    'time': time
                                                })
                                                
                                        def getHighestConfidencePattern(self):
                                            if len(self.confidences) > 0:
                                                maxIdx = self.confidences.index(max(self.confidences))
                                                return (self.patterns[maxIdx], self.signals[maxIdx], self.confidences[maxIdx])
                                            return None
                                            
                                        def generateAlerts(self):
                                            for alert in self.alerts:
                                                message = f"""
                                                High Confidence Pattern Detected!
                                                Pattern: {alert['pattern']}
                                                Signal: {'BUY' if alert['signal']==1 else 'SELL'} 
                                                Confidence: {alert['confidence']:.2f}
                                                Price: {alert['price']}
                                                Time: {alert['time']}
                                                """
                                                alert(message)

                                    # Enhanced Pattern Scanner 
                                    def enhancedPatternScanner():
                                        signals = SmartSignals()
                                        
                                        # Scan for Quasimodo
                                        if isQuasimodoBullish():
                                            signals.addPattern('Bullish QM', 1, 0.8)
                                        elif isQuasimodoBearish():  
                                            signals.addPattern('Bearish QM', -1, 0.8)
                                            
                                        # Scan for BSZ
                                        if isBreakoutStopZone():
                                            bszSignal = 1 if close > high[5] else -1
                                            signals.addPattern('BSZ', bszSignal, 0.75)
                                            
                                        # Scan for Order Blocks
                                        if isOrderBlock():
                                            obSignal = 1 if close > open else -1
                                            signals.addPattern('Order Block', obSignal, 0.7)
                                            
                                        # Scan for FVG
                                        if isFairValueGap():
                                            fvgSignal = 1 if low[2] > high[0] else -1  
                                            signals.addPattern('FVG', fvgSignal, 0.65)
                                            
                                        # Scan for Three Drive
                                        if detectThreeDrivePattern():
                                            signals.addPattern('Three Drive', getThreeDriveSignal(), 0.8)
                                            
                                        # Scan for Compression
                                        if detectCompression():
                                            signals.addPattern('Compression', 0, 0.6)
                                            
                                        # Scan for Liquidity Void
                                        if detectLiquidityVoid():
                                            signals.addPattern('Liquidity Void', 0, 0.7)
                                            
                                        return signals

                                    # Risk Management Class
                                    class RiskManager:
                                        def __init__(self, equity, riskPerTrade=0.01):
                                            self.equity = equity
                                            self.riskPerTrade = riskPerTrade
                                            
                                        def calculatePositionSize(self, entryPrice, stopPrice):
                                            risk = abs(entryPrice - stopPrice)
                                            riskAmount = self.equity * self.riskPerTrade
                                            return riskAmount / risk
                                            
                                        def adjustPositionSize(self, confidence):
                                            return self.riskPerTrade * confidence
                                            
                                        def getDynamicStopLoss(self, entryPrice, atr):
                                            return 2 * atr

                                    # Performance Tracker
                                    class PerformanceTracker:
                                        def __init__(self):
                                            self.trades = []
                                            self.wins = 0
                                            self.losses = 0
                                            self.totalProfit = 0
                                            self.maxDrawdown = 0
                                            
                                        def addTrade(self, entry, exit, profit):
                                            self.trades.append({
                                                'entry': entry,
                                                'exit': exit,
                                                'profit': profit
                                            })
                                            
                                            if profit > 0:
                                                self.wins += 1
                                            else:
                                                self.losses += 1
                                                
                                            self.totalProfit += profit
                                            self.updateDrawdown()
                                            
                                        def updateDrawdown(self):
                                            if len(self.trades) > 0:
                                                equity = [0]
                                                for trade in self.trades:
                                                    equity.append(equity[-1] + trade['profit'])
                                                
                                                peak = max(equity)
                                                self.maxDrawdown = min([x - peak for x in equity])
                                                
                                        def getStats(self):
                                            total = self.wins + self.losses
                                            winRate = self.wins/total if total > 0 else 0
                                            
                                            return {
                                                'totalTrades': total,
                                                'winRate': winRate,
                                                'totalProfit': self.totalProfit,
                                                'maxDrawdown': self.maxDrawdown
                                            }

                                    # Main Strategy Loop
                                    def main():
                                        # Initialize components
                                        signals = enhancedPatternScanner()
                                        riskManager = RiskManager(equity=100000)
                                        performance = PerformanceTracker()
                                        
                                        # Process signals
                                        if barstate.islast:
                                            # Get highest confidence pattern
                                            topPattern = signals.getHighestConfidencePattern()
                                            
                                            if topPattern:
                                                pattern, signal, confidence = topPattern
                                                
                                                # Calculate position size
                                                if signal != 0:
                                                    entry = close
                                                    stop = entry - riskManager.getDynamicStopLoss(entry, atr(14)) if signal==1 else entry + riskManager.getDynamicStopLoss(entry, atr(14))
                                                    posSize = riskManager.calculatePositionSize(entry, stop)
                                                    posSize = riskManager.adjustPositionSize(confidence)
                                                    
                                                    # Generate alerts
                                                    signals.generateAlerts()
                                                    
                                                    # Update pattern table
                                                    displayPatternTable(signals.patterns, signals.confidences)
                                                    
                                                    # Plot signals
                                                    plotSignals(signals.patterns, signals.signals)
                                                    
                                                    # Update performance metrics
                                                    if len(signals.patterns) > 0:
                                                        performance.addTrade(entry, close, (close-entry)/entry if signal==1 else (entry-close)/entry)
                                                        stats = performance.getStats()
                                                        updatePerformanceTable(stats)

                                    # Run strategy
                                    main()
                                    # Advanced Smart Money Analysis Functions
                                    def analyzeSmartMoney():
                                        # Initialize variables 
                                        smSignals = []
                                        smConfidence = []

                                        # Check Order Blocks
                                        if isOrderBlock():
                                            smSignals.append("Order Block Detected")
                                            smConfidence.append(0.8)
                                            
                                        # Check Fair Value Gap
                                        if isFairValueGap():
                                            smSignals.append("Fair Value Gap Detected") 
                                            smConfidence.append(0.75)
                                            
                                        # Check BSZ Pattern
                                        if isBreakoutStopZone():
                                            smSignals.append("BSZ Pattern Detected")
                                            smConfidence.append(0.85)

                                        return smSignals, smConfidence

                                    # Advanced Pattern Recognition
                                    def smartPatternRecognition():
                                        # Initialize pattern arrays
                                        patterns = []
                                        confidence = []
                                        
                                        # QM Pattern Detection
                                        qmResult = detectQuasimodoBullish() or detectQuasimodoBearish()
                                        if qmResult:
                                            patterns.append("Quasimodo Pattern")
                                            confidence.append(0.9)
                                            
                                        # 3-Drive Pattern
                                        if detectThreeDrivePattern():
                                            patterns.append("Three Drive Pattern") 
                                            confidence.append(0.8)
                                            
                                        # Compression Pattern
                                        if detectCompression():
                                            patterns.append("Compression Pattern")
                                            confidence.append(0.75)
                                            
                                        return patterns, confidence

                                    # Smart Money Alert System
                                    def generateSmartMoneyAlerts():
                                        # Get current analysis
                                        smSignals, smConfidence = analyzeSmartMoney()
                                        patterns, patternConfidence = smartPatternRecognition()
                                        
                                        # Generate alerts for high confidence setups
                                        for i in range(len(smSignals)):
                                            if smConfidence[i] > 0.7:
                                                alert(f"""
                                                Smart Money Signal: {smSignals[i]}
                                                Confidence: {smConfidence[i]}
                                                Current Price: {close}
                                                Time: {time}
                                                """)
                                                
                                        for i in range(len(patterns)):
                                            if patternConfidence[i] > 0.7:
                                                alert(f"""
                                                Pattern Detected: {patterns[i]}
                                                Confidence: {patternConfidence[i]}
                                                Current Price: {close} 
                                                Time: {time}
                                                """)

                                    # Dynamic Risk Management
                                    class DynamicRiskManager:
                                        def __init__(self):
                                            self.maxRisk = input(1.0, "Max Risk Per Trade %")
                                            self.confidenceMultiplier = input(1.5, "Confidence Multiplier")
                                            
                                        def calculatePositionSize(self, confidence):
                                            # Adjust position size based on setup confidence
                                            adjustedRisk = self.maxRisk * confidence * self.confidenceMultiplier
                                            return adjustedRisk
                                            
                                        def getStopLoss(self, entryPrice, atr):  
                                            return atr * 2 # Dynamic stop based on volatility

                                    # Initialize components
                                    riskManager = DynamicRiskManager()
                                    performanceTracker = PerformanceTracker()

                                    # Main Strategy Loop
                                    def executeStrategy():
                                        # Run pattern analysis
                                        smSignals, smConfidence = analyzeSmartMoney()
                                        patterns, patternConfidence = smartPatternRecognition()
                                        
                                        # Generate alerts
                                        generateSmartMoneyAlerts()
                                        
                                        # Calculate trading signals
                                        for i in range(len(smSignals)):
                                            if smConfidence[i] > 0.7:
                                                # Calculate position size
                                                posSize = riskManager.calculatePositionSize(smConfidence[i])
                                                
                                                # Get stop loss
                                                stopLoss = riskManager.getStopLoss(close, ta.atr(14))
                                                
                                                # Track performance
                                                performanceTracker.addTrade({
                                                    'entry': close,
                                                    'stop': stopLoss,
                                                    'confidence': smConfidence[i],
                                                    'pattern': smSignals[i]
                                                })
                                                
                                                # Plot signals on chart
                                                plotshape(true, style=shape.triangleup if smSignals[i].startswith("Buy") else shape.triangledown,
                                                         location=location.belowbar if smSignals[i].startswith("Buy") else location.abovebar,  
                                                         color=color.green if smSignals[i].startswith("Buy") else color.red,
                                                         size=size.small)
                                                         
                                    # Update performance metrics
                                    if barstate.islast:
                                        stats = performanceTracker.getStats()
                                        
                                        # Display metrics in table
                                        table.cell(performanceTable, 0, 0, "Win Rate", stats['winRate'])
                                        table.cell(performanceTable, 0, 1, "Total Profit", stats['totalProfit'])
                                        table.cell(performanceTable, 0, 2, "Max Drawdown", stats['maxDrawdown'])
                                        
                                        # Export performance data
                                        alert(f"""
                                        === Performance Report ===
                                        Win Rate: {stats['winRate']}%
                                        Total Profit: {stats['totalProfit']}
                                        Max Drawdown: {stats['maxDrawdown']}
                                        Total Trades: {stats['totalTrades']}
                                        """)

                                    # Execute strategy
                                    # Advanced Pattern Recognition with AI and Machine Learning
                                    class AIPatternDetector:
                                        def __init__(self):
                                            self.patterns = {
                                                'QM': {'enabled': true, 'weight': 0.3}, 
                                                'BSZ': {'enabled': true, 'weight': 0.25},
                                                'OB': {'enabled': true, 'weight': 0.2},
                                                'FVG': {'enabled': true, 'weight': 0.15},
                                                'PAZ': {'enabled': true, 'weight': 0.1},
                                                '3D': {'enabled': true, 'weight': 0.2}
                                            }
                                            
                                            self.confidence_threshold = input(0.7, 'Confidence Threshold')
                                            self.lookback = input(20, 'Pattern Lookback')
                                            
                                        def detect_patterns(self):
                                            detected = []
                                            for pattern, config in self.patterns.items():
                                                if not config['enabled']:
                                                    continue
                                                    
                                                # Detect pattern based on type
                                                if pattern == 'QM':
                                                    if self.detect_quasimodo():
                                                        detected.append({
                                                            'type': pattern,
                                                            'confidence': self.calculate_confidence('QM'),
                                                            'signal': self.get_qm_signal()
                                                        })
                                                        
                                                elif pattern == 'BSZ': 
                                                    if self.detect_bsz():
                                                        detected.append({
                                                            'type': pattern,
                                                            'confidence': self.calculate_confidence('BSZ'),
                                                            'signal': self.get_bsz_signal()
                                                        })
                                                        
                                                # Similar detection for other patterns
                                                
                                            return detected
                                            
                                        def calculate_confidence(self, pattern_type):
                                            confidence = 0.0
                                            
                                            # Base confidence from pattern weight
                                            confidence += self.patterns[pattern_type]['weight']
                                            
                                            # Add volume confirmation 
                                            if volume > sma(volume, 20):
                                                confidence += 0.1
                                                
                                            # Add trend confirmation
                                            if close > sma(close, 200):
                                                confidence += 0.1
                                                
                                            # Add volatility confirmation
                                            if atr(14) > sma(atr(14), 20): 
                                                confidence += 0.1
                                                
                                            return confidence

                                    # Smart Money Flow Analysis
                                    class SmartMoneyAnalyzer:
                                        def __init__(self):
                                            self.institutions = []
                                            self.retail = []
                                            
                                        def analyze_flow(self):
                                            # Analyze institutional order flow
                                            inst_flow = self.get_institutional_flow()
                                            
                                            # Analyze retail order flow
                                            retail_flow = self.get_retail_flow()
                                            
                                            # Compare and find divergences
                                            divergences = self.find_divergences(inst_flow, retail_flow)
                                            
                                            return {
                                                'institutional': inst_flow,
                                                'retail': retail_flow,
                                                'divergences': divergences
                                            }
                                            
                                        def get_institutional_flow(self):
                                            # Analyze large orders and institutional patterns
                                            pass
                                            
                                        def get_retail_flow(self):
                                            # Analyze retail trading patterns
                                            pass
                                            
                                        def find_divergences(self, inst, retail):
                                            # Find divergences between institutional and retail flow
                                            pass

                                    # Advanced Risk Management
                                    class RiskManager:
                                        def __init__(self):
                                            self.max_risk = input(2.0, "Max Risk Per Trade %")
                                            self.position_sizing = input("ATR", "Position Sizing", options=["Fixed", "ATR", "Volatility"])
                                            
                                        def calculate_position_size(self, entry, stop, confidence):
                                            risk = abs(entry - stop)
                                            
                                            # Adjust risk based on confidence
                                            adjusted_risk = self.max_risk * confidence
                                            
                                            if self.position_sizing == "ATR":
                                                size = adjusted_risk / (atr(14) * 2)
                                            elif self.position_sizing == "Volatility":
                                                size = adjusted_risk / stdev(close, 20)
                                            else:
                                                size = adjusted_risk / risk
                                                
                                            return size
                                            
                                        def get_dynamic_stops(self, entry, direction):
                                            atr_val = atr(14)
                                            
                                            if direction == "long":
                                                stop = entry - (atr_val * 2)
                                                target1 = entry + (atr_val * 3)
                                                target2 = entry + (atr_val * 5)
                                            else:
                                                stop = entry + (atr_val * 2) 
                                                target1 = entry - (atr_val * 3)
                                                target2 = entry - (atr_val * 5)
                                                
                                            return {
                                                'stop': stop,
                                                'target1': target1, 
                                                'target2': target2
                                            }

                                    # Smart Alert System 
                                    class AlertSystem:
                                        def __init__(self):
                                            self.min_confidence = input(0.7, "Minimum Alert Confidence")
                                            self.patterns_required = input(2, "Minimum Patterns Required")
                                            
                                        def check_alerts(self, patterns, smart_money):
                                            if len(patterns) < self.patterns_required:
                                                return
                                                
                                            # Calculate overall confidence
                                            total_conf = sum([p['confidence'] for p in patterns]) / len(patterns)
                                            
                                            if total_conf < self.min_confidence:
                                                return
                                                
                                            # Generate alert message
                                            msg = f"""
                                            === Smart Money Alert ===
                                            Patterns Detected: {len(patterns)}
                                            Total Confidence: {total_conf:.2f}
                                            
                                            Patterns:
                                            """
                                            
                                            for p in patterns:
                                                msg += f"- {p['type']}: {p['confidence']:.2f}\n"
                                                
                                            msg += f"""
                                            Smart Money Flow:
                                            Institutional: {smart_money['institutional']}
                                            Retail: {smart_money['retail']}
                                            
                                            Current Price: {close}
                                            """
                                            
                                            alert(msg)

                                    # Performance Tracking
                                    class PerformanceTracker:
                                        def __init__(self):
                                            self.trades = []
                                            self.metrics = {
                                                'wins': 0,
                                                'losses': 0,
                                                'profit': 0,
                                                'max_drawdown': 0
                                            }
                                            
                                        def add_trade(self, entry, exit, pattern):
                                            profit = exit - entry
                                            
                                            self.trades.append({
                                                'entry': entry,
                                                'exit': exit,
                                                'profit': profit,
                                                'pattern': pattern
                                            })
                                            
                                            if profit > 0:
                                                self.metrics['wins'] += 1
                                            else:
                                                self.metrics['losses'] += 1
                                                
                                            self.metrics['profit'] += profit
                                            self.update_drawdown()
                                            
                                        def update_drawdown(self):
                                            # Calculate running drawdown
                                            pass
                                            
                                        def get_stats(self):
                                            total = len(self.trades)
                                            if total == 0:
                                                return self.metrics
                                                
                                            self.metrics['win_rate'] = self.metrics['wins'] / total
                                            self.metrics['avg_profit'] = self.metrics['profit'] / total
                                            
                                            return self.metrics

                                    # Main Strategy Implementation
                                    class SmartMoneyStrategy:
                                        def __init__(self):
                                            self.detector = AIPatternDetector()
                                            self.analyzer = SmartMoneyAnalyzer()
                                            self.risk = RiskManager()
                                            self.alerts = AlertSystem()
                                            self.performance = PerformanceTracker()
                                            
                                        def run(self):
                                            # Detect patterns
                                            patterns = self.detector.detect_patterns()
                                            
                                            # Analyze smart money flow
                                            smart_money = self.analyzer.analyze_flow()
                                            
                                            # Generate alerts if needed
                                            self.alerts.check_alerts(patterns, smart_money)
                                            
                                            # Handle trading logic
                                            for pattern in patterns:
                                                if pattern['confidence'] >= self.detector.confidence_threshold:
                                                    entry = close
                                                    
                                                    # Get stops and targets
                                                    levels = self.risk.get_dynamic_stops(entry, pattern['signal'])
                                                    
                                                    # Calculate position size
                                                    size = self.risk.calculate_position_size(
                                                        entry, levels['stop'], pattern['confidence']
                                                    )
                                                    
                                                    # Place trade and track performance
                                                    if pattern['signal'] == 'long':
                                                        strategy.entry("Long", strategy.long, size, 
                                                            stop=levels['stop'],
                                                            limit=levels['target1'])
                                                            
                                                    elif pattern['signal'] == 'short':
                                                        strategy.entry("Short", strategy.short, size,
                                                            stop=levels['stop'], 
                                                            limit=levels['target1'])
                                                            
                                            # Update performance metrics
                                            if strategy.position_size != 0:
                                                self.performance.add_trade(
                                                    strategy.position_avg_price,
                                                    close,
                                                    patterns[0]['type']
                                                )
                                                
                                            # Display current stats
                                            stats = self.performance.get_stats()
                                            
                                            table.cell(statsTable, 0, 0, "Win Rate", f"{stats['win_rate']:.2%}")
                                            table.cell(statsTable, 0, 1, "Profit", f"{stats['profit']:.2f}")
                                            table.cell(statsTable, 0, 2, "Drawdown", f"{stats['max_drawdown']:.2f}")

                                    # Initialize and run strategy
                                    strategy = SmartMoneyStrategy()
                                    strategy.run()
                                    # Advanced Pattern Detection and Analysis System

                                    class SmartPatternAnalyzer:
                                        def __init__(self):
                                            # User customizable settings
                                            self.settings = {
                                                'enableQM': input(true, "Enable Quasimodo Pattern"),
                                                'enableBSZ': input(true, "Enable BSZ Pattern"),
                                                'enableOB': input(true, "Enable Order Block"),
                                                'enableFVG': input(true, "Enable Fair Value Gap"),
                                                'enable3D': input(true, "Enable Three Drive Pattern"),
                                                'minConfidence': input(0.7, "Minimum Pattern Confidence", 0.1, 1.0),
                                                'riskPerTrade': input(1.0, "Risk Per Trade %", 0.1, 5.0),
                                                'useMLConfirmation': input(true, "Use ML Confirmation"),
                                                'alertOnPattern': input(true, "Alert on Pattern Formation"),
                                                'timeframes': input("ALL", "Analysis Timeframes", options=["M1", "M5", "M15", "H1", "H4", "D1", "ALL"])
                                            }
                                            
                                            self.detectedPatterns = []
                                            self.activeAlerts = []
                                            
                                        def scanAllPatterns(self):
                                            patterns = []
                                            
                                            if self.settings['enableQM']:
                                                qm = self.detectQuasimodo()
                                                if qm:
                                                    patterns.append(qm)
                                                    
                                            if self.settings['enableBSZ']:
                                                bsz = self.detectBSZ()
                                                if bsz:
                                                    patterns.append(bsz)
                                                    
                                            if self.settings['enableOB']:
                                                ob = self.detectOrderBlock()
                                                if ob:
                                                    patterns.append(ob)
                                                    
                                            if self.settings['enableFVG']:
                                                fvg = self.detectFairValueGap()
                                                if fvg:
                                                    patterns.append(fvg)
                                                    
                                            if self.settings['enable3D']:
                                                td = self.detectThreeDrive()
                                                if td:
                                                    patterns.append(td)
                                                    
                                            return self.validatePatterns(patterns)
                                            
                                        def validatePatterns(self, patterns):
                                            validated = []
                                            
                                            for pattern in patterns:
                                                confidence = self.calculateConfidence(pattern)
                                                if confidence >= self.settings['minConfidence']:
                                                    if self.settings['useMLConfirmation']:
                                                        mlScore = self.getMLConfirmation(pattern)
                                                        confidence = (confidence + mlScore) / 2
                                                        
                                                    pattern['confidence'] = confidence
                                                    validated.append(pattern)
                                                    
                                            return validated
                                            
                                        def calculateConfidence(self, pattern):
                                            confidence = 0.0
                                            
                                            # Volume confirmation
                                            if volume > ta.sma(volume, 20):
                                                confidence += 0.2
                                                
                                            # Trend confirmation
                                            if close > ta.sma(close, 200):
                                                confidence += 0.1
                                                
                                            # Multiple timeframe confirmation
                                            if self.checkMultipleTimeframes(pattern):
                                                confidence += 0.2
                                                
                                            # Add pattern-specific confidence factors
                                            confidence += self.getPatternSpecificConfidence(pattern)
                                            
                                            return min(confidence, 1.0)
                                            
                                        def getMLConfirmation(self, pattern):
                                            # Initialize ML features
                                            features = []
                                            
                                            # Price action features
                                            features.append(ta.rsi(close, 14))
                                            features.append(ta.macd(close, 12, 26, 9))
                                            features.append(ta.atr(14))
                                            
                                            # Volume features
                                            features.append(volume / ta.sma(volume, 20))
                                            
                                            # Pattern specific features
                                            features.extend(self.getPatternSpecificFeatures(pattern))
                                            
                                            # Get prediction from ML model
                                            return self.mlModel.predict(features)
                                            
                                        def generateAlerts(self, patterns):
                                            for pattern in patterns:
                                                if self.settings['alertOnPattern']:
                                                    alert_msg = f"""
                                                    Pattern Detected: {pattern['type']}
                                                    Confidence: {pattern['confidence']:.2f}
                                                    Entry Price: {close}
                                                    Time: {time}
                                                    Suggested Stop Loss: {pattern['stopLoss']}
                                                    Target: {pattern['target']}
                                                    """
                                                    alert(alert_msg)
                                                    
                                                    self.activeAlerts.append({
                                                        'type': pattern['type'],
                                                        'price': close,
                                                        'time': time,
                                                        'confidence': pattern['confidence']
                                                    })
                                                    
                                        def displayVisualizations(self):
                                            if barstate.islast:
                                                # Create pattern table
                                                table.clear(patternTable)
                                                table.cell(patternTable, 0, 0, "Active Patterns", bgcolor=color.blue)
                                                table.cell(patternTable, 1, 0, "Confidence", bgcolor=color.blue)
                                                table.cell(patternTable, 2, 0, "Entry", bgcolor=color.blue)
                                                
                                                row = 1
                                                for pattern in self.detectedPatterns:
                                                    table.cell(patternTable, 0, row, pattern['type'])
                                                    table.cell(patternTable, 1, row, str(pattern['confidence']))
                                                    table.cell(patternTable, 2, row, str(close))
                                                    row += 1
                                                    
                                                # Plot pattern markers on chart
                                                for pattern in self.detectedPatterns:
                                                    if pattern['signal'] == 'long':
                                                        plotshape(true, "Long", shape.triangleup, 
                                                                 location=location.belowbar, color=color.green, size=size.small)
                                                    else:
                                                        plotshape(true, "Short", shape.triangledown,
                                                                 location=location.abovebar, color=color.red, size=size.small)
                                                                 
                                        def updateRiskManagement(self):
                                            if len(self.detectedPatterns) > 0:
                                                pattern = self.detectedPatterns[0]
                                                
                                                # Calculate position size
                                                risk = self.settings['riskPerTrade'] / 100
                                                stopDistance = abs(close - pattern['stopLoss'])
                                                positionSize = (equity * risk) / stopDistance
                                                
                                                # Update risk table
                                                table.cell(riskTable, 0, 0, "Pattern", pattern['type'])
                                                table.cell(riskTable, 0, 1, "Position Size", str(positionSize))
                                                table.cell(riskTable, 0, 2, "Stop Loss", str(pattern['stopLoss']))
                                                table.cell(riskTable, 0, 3, "Target", str(pattern['target']))

                                    # Initialize and run strategy
                                    analyzer = SmartPatternAnalyzer()

                                    if barstate.islast
                                        # Scan for patterns
                                        patterns = analyzer.scanAllPatterns()
                                        
                                        # Generate alerts
                                        analyzer.generateAlerts(patterns)
                                        
                                        # Update visualizations
                                        analyzer.displayVisualizations()
                                        
                                        # Update risk management
                                        analyzer.updateRiskManagement()
                                        //@version=5
indicator("RTM Supreme Strategy", shorttitle="RTM-SUPREME", overlay=true, max_lines_count=500, max_labels_count=500, precision=2)

// ======== INPUT PARAMETERS ========
// General Settings
strategyMode = input.bool(false, "Enable Strategy Mode", group="General Settings")
showLabels = input.bool(true, "Show Pattern Labels", group="General Settings")
showAlerts = input.bool(true, "Enable Alerts", group="General Settings")

// Pattern Detection Settings
enablePAZ = input.bool(true, "Price Action Zones (PAZ)", group="Pattern Detection")
enableQM = input.bool(true, "Quasimodo Patterns", group="Pattern Detection")
enableBSZ = input.bool(true, "Breakout/Stop Zones", group="Pattern Detection")
enableOB = input.bool(true, "Order Blocks", group="Pattern Detection")
enableFVG = input.bool(true, "Fair Value Gaps", group="Pattern Detection")
enableLQ = input.bool(true, "Liquidity Zones", group="Pattern Detection")

// Advanced Parameters
sensitivity = input.int(3, "Pattern Sensitivity", minval=1, maxval=5, group="Advanced")
riskReward = input.float(3.0, "Risk/Reward Ratio", minval=1.0, maxval=10.0, group="Advanced")
maxHistory = input.int(200, "Max Historical Bars", minval=50, maxval=1000, group="Advanced")

// ======== CORE FUNCTIONS ========
// Pattern Detection Engine
detectPAZ() =>
    pazZones = array.new_float(0)
    // PAZ detection logic here
    pazZones

detectQM() =>
    qmPatterns = array.new_string(0)
    // Quasimodo detection logic
    qmPatterns

detectBSZ() =>
    bszZones = array.new_float(0)
    // BSZ detection logic
    bszZones

detectOB() =>
    obBlocks = array.new_float(0)
    // Order Block detection
    obBlocks

detectFVG() =>
    fvgGaps = array.new_float(0)
    // FVG detection logic
    fvgGaps

detectLQ() =>
    lqZones = array.new_float(0)
    // Liquidity Zones detection
    lqZones

// ======== INTELLIGENT ANALYSIS ========
analyzeMarketStructure() =>
    bullPower = ta.ema(close - low, 14)
    bearPower = ta.ema(high - close, 14)
    marketBias = bullPower > bearPower ? "Bullish" : "Bearish"
    marketBias

// ======== ALERT SYSTEM ========
checkAlerts() =>
    alertMessage = ""
    // Alert conditions here
    alertMessage

// ======== VISUALIZATION ========
drawPatterns() =>
    if showLabels
        // Drawing logic for all patterns
        label.new(bar_index, high, "PAZ Detected", color=color.blue)

// ======== MAIN LOGIC ========
var string marketStatus = "Neutral"

if barstate.islast
    marketStatus = analyzeMarketStructure()
    
    // Detect patterns
    paz = enablePAZ ? detectPAZ() : na
    qm = enableQM ? detectQM() : na
    bsz = enableBSZ ? detectBSZ() : na
    ob = enableOB ? detectOB() : na
    fvg = enableFVG ? detectFVG() : na
    lq = enableLQ ? detectLQ() : na
    
    // Generate alerts
    alertMsg = checkAlerts()
    if showAlerts and alertMsg != ""
        alert(alertMsg, alert.freq_once_per_bar)
    
    // Update display
    drawPatterns()

// ======== STRATEGY ENGINE ========
if strategyMode
    // Strategy execution logic
    strategy.entry("Long", strategy.long, when=detectQM() and marketStatus == "Bullish")
    strategy.exit("Exit", "Long", profit=close * riskReward)

// ======== FINAL OUTPUT ========
plotshape(showLabels and enableQM, style=shape.triangleup, color=color.green, location=location.belowbar)
plotshape(showLabels and enablePAZ, style=shape.flag, color=color.blue, location=location.abovebar)

// Table Display
var table infoTable = table.new(position.top_right, 5, 5)
if barstate.islast
    table.cell(infoTable, 0, 0, "Market Status: " + marketStatus)
    table.cell(infoTable, 0, 1, "Active Patterns: " + str.tostring(array.size(qm)) + " QM")

    // Advanced Pattern Recognition System
    patternRecognitionSystem() =>
        var struct PatternData 
            float confidence
            string type
            string direction
            float entry
            float stop
            float target
            string timeframe
            bool isActive

        var patterns = array.new<PatternData>()
        
        // Pattern Scanners
        scanQuasimodo() =>
            bullish = low[4] > low[2] and high[3] > high[1] and low[2] < low[0]
            bearish = high[4] < high[2] and low[3] < low[1] and high[2] > high[0]
            
            if bullish or bearish
                pattern = PatternData.new()
                pattern.type = "Quasimodo"
                pattern.direction = bullish ? "Long" : "Short" 
                pattern.confidence = calculatePatternConfidence("QM")
                pattern.entry = close
                pattern.stop = bullish ? low[2] : high[2]
                pattern.target = calculateTarget(pattern)
                pattern.timeframe = timeframe.period
                pattern.isActive = true
                array.push(patterns, pattern)

        scanOrderBlocks() =>
            bullOB = high[1] < low and close > open and volume > ta.sma(volume, 20)
            bearOB = low[1] > high and close < open and volume > ta.sma(volume, 20)
            
            if bullOB or bearOB
                pattern = PatternData.new()
                pattern.type = "Order Block"
                pattern.direction = bullOB ? "Long" : "Short"
                pattern.confidence = calculatePatternConfidence("OB")
                pattern.entry = close 
                pattern.stop = bullOB ? low[1] : high[1]
                pattern.target = calculateTarget(pattern)
                pattern.timeframe = timeframe.period
                pattern.isActive = true
                array.push(patterns, pattern)

        scanBSZ() =>
            range = high[5] - low[5]
            bszTop = high[5] + range * 0.1
            bszBottom = low[5] - range * 0.1
            
            if close > bszTop or close < bszBottom
                pattern = PatternData.new()
                pattern.type = "BSZ"
                pattern.direction = close > bszTop ? "Long" : "Short"
                pattern.confidence = calculatePatternConfidence("BSZ")
                pattern.entry = close
                pattern.stop = close > bszTop ? bszBottom : bszTop
                pattern.target = calculateTarget(pattern)
                pattern.timeframe = timeframe.period
                pattern.isActive = true
                array.push(patterns, pattern)

        // Smart Money Analysis
        analyzeSmartMoney() =>
            var struct SmartMoneyData
                float institutional_volume
                float retail_volume
                string flow_direction
                float liquidity_level
                
            smData = SmartMoneyData.new()
            smData.institutional_volume = ta.sma(volume * (high - low), 20)
            smData.retail_volume = volume - smData.institutional_volume
            smData.flow_direction = smData.institutional_volume > smData.retail_volume ? "UP" : "DOWN"
            smData.liquidity_level = ta.highest(volume, 50)
            
            smData

        // AI-Based Pattern Validation
        validatePattern(pattern) =>
            score = 0.0
            
            // Volume validation
            score += volume > ta.sma(volume, 20) ? 0.2 : 0
            
            // Trend validation
            score += close > ta.sma(close, 200) ? 0.15 : 0
            
            // Volatility validation
            score += ta.atr(14) > ta.sma(ta.atr(14), 14) ? 0.15 : 0
            
            // Pattern specific validation
            if pattern.type == "Quasimodo"
                score += validateQuasimodo(pattern)
            else if pattern.type == "Order Block"
                score += validateOrderBlock(pattern)
            else if pattern.type == "BSZ"
                score += validateBSZ(pattern)
                
            score

        // Dynamic Risk Management
        calculatePositionSize(pattern) =>
            risk = input.float(1.0, "Risk Per Trade %")
            stopDistance = math.abs(pattern.entry - pattern.stop)
            accountRisk = strategy.equity * (risk / 100)
            positionSize = accountRisk / stopDistance
            
            positionSize

        // Pattern Alert System
        alertSystem() =>
            var lastAlert = 0
            
            if array.size(patterns) > 0 and (time - lastAlert) > 60000  // Minimum 1 minute between alerts
                for pattern in patterns
                    if pattern.isActive and pattern.confidence >= 0.7
                        alert_message = "🔔 " + pattern.type + " Pattern Detected!\n" +
                                      "Direction: " + pattern.direction + "\n" +
                                      "Confidence: " + str.tostring(pattern.confidence) + "\n" +
                                      "Entry: " + str.tostring(pattern.entry) + "\n" +
                                      "Stop: " + str.tostring(pattern.stop) + "\n" +
                                      "Target: " + str.tostring(pattern.target) + "\n" +
                                      "Timeframe: " + pattern.timeframe
                                      
                        alert(alert_message, alert.freq_once_per_bar_close)
                        lastAlert := time

        // Smart Entry and Exit Management
        managePositions() =>
            if strategy.position_size == 0
                for pattern in patterns
                    if pattern.isActive and pattern.confidence >= 0.8
                        size = calculatePositionSize(pattern)
                        if pattern.direction == "Long"
                            strategy.entry("Long " + pattern.type, strategy.long, size, 
                                stop=pattern.stop, limit=pattern.target)
                        else
                            strategy.entry("Short " + pattern.type, strategy.short, size,
                                stop=pattern.stop, limit=pattern.target)
            else
                // Manage open positions
                updateStops()
                checkForExit()

        // Pattern Dashboard
        displayDashboard() =>
            var table dashboard = table.new(position.top_right, 6, 10, bgcolor=color.new(color.black, 90))
            
            if barstate.islast
                table.cell(dashboard, 0, 0, "Pattern Type", bgcolor=color.new(color.blue, 90))
                table.cell(dashboard, 1, 0, "Direction", bgcolor=color.new(color.blue, 90))
                table.cell(dashboard, 2, 0, "Confidence", bgcolor=color.new(color.blue, 90))
                table.cell(dashboard, 3, 0, "Entry", bgcolor=color.new(color.blue, 90))
                table.cell(dashboard, 4, 0, "Stop", bgcolor=color.new(color.blue, 90))
                table.cell(dashboard, 5, 0, "Target", bgcolor=color.new(color.blue, 90))
                
                row = 1
                for pattern in patterns
                    if pattern.isActive and row <= 9
                        table.cell(dashboard, 0, row, pattern.type)
                        table.cell(dashboard, 1, row, pattern.direction)
                        table.cell(dashboard, 2, row, str.tostring(pattern.confidence))
                        table.cell(dashboard, 3, row, str.tostring(pattern.entry))
                        table.cell(dashboard, 4, row, str.tostring(pattern.stop))
                        table.cell(dashboard, 5, row, str.tostring(pattern.target))
                        row += 1

        // Main Execution Loop
        if barstate.islast
            array.clear(patterns)
            
            // Scan for patterns
            scanQuasimodo()
            scanOrderBlocks()
            scanBSZ()
            
            // Analyze Smart Money flow
            smAnalysis = analyzeSmartMoney()
            
            // Validate patterns
            for pattern in patterns
                pattern.confidence := validatePattern(pattern)
            
            // Generate alerts
            alertSystem()
            
            // Manage positions
            if strategyMode
                managePositions()
            
            // Update dashboard
            displayDashboard()

    // Call the pattern recognition system
    patternRecognitionSystem()
    # Smart Money Pattern Recognition System
    class SmartPatternEngine:
        def __init__(self):
            self.patterns = []
            self.confidence_threshold = 0.7
            self.indicators = []
            self.active_patterns = {}
            
        def add_indicator(self, name, timeframe='', params={}):
            self.indicators.append({
                'name': name,
                'timeframe': timeframe,
                'params': params,
                'active': True
            })
            
        def scan_patterns(self, data):
            # Reset active patterns
            self.active_patterns = {}
            
            # Scan for all enabled patterns
            self._scan_quasimodo(data)
            self._scan_order_blocks(data) 
            self._scan_bsz(data)
            self._scan_fvg(data)
            self._scan_liquidity_zones(data)
            
            # Calculate confidence scores
            self._calculate_confidence_scores()
            
            # Generate alerts for high confidence patterns
            self._generate_alerts()
            
            return self.active_patterns
            
        def _scan_quasimodo(self, data):
            # QM Pattern detection logic
            bullish_qm = (data['low'][-4] > data['low'][-2] and 
                          data['high'][-3] > data['high'][-1] and 
                          data['low'][-2] < data['low'][0])
                          
            bearish_qm = (data['high'][-4] < data['high'][-2] and
                          data['low'][-3] < data['low'][-1] and 
                          data['high'][-2] > data['high'][0])
                          
            if bullish_qm or bearish_qm:
                self.active_patterns['QM'] = {
                    'type': 'QM',
                    'direction': 'long' if bullish_qm else 'short',
                    'strength': 0,
                    'entry': data['close'][-1],
                    'stop': data['low'][-2] if bullish_qm else data['high'][-2],
                    'targets': []
                }
                
        def _scan_order_blocks(self, data):
            # Order Block detection
            bull_ob = (data['high'][-2] < data['low'][-1] and
                      data['close'][-1] > data['open'][-1])
                      
            bear_ob = (data['low'][-2] > data['high'][-1] and
                      data['close'][-1] < data['open'][-1])
                      
            if bull_ob or bear_ob:
                self.active_patterns['OB'] = {
                    'type': 'OB', 
                    'direction': 'long' if bull_ob else 'short',
                    'strength': 0,
                    'entry': data['close'][-1],
                    'stop': data['low'][-2] if bull_ob else data['high'][-2],
                    'targets': []
                }

        def _scan_bsz(self, data):
            # BSZ Pattern detection  
            range_size = data['high'][-5] - data['low'][-5]
            bsz_top = data['high'][-5] + range_size * 0.1
            bsz_bottom = data['low'][-5] - range_size * 0.1
            
            if data['close'][-1] > bsz_top or data['close'][-1] < bsz_bottom:
                self.active_patterns['BSZ'] = {
                    'type': 'BSZ',
                    'direction': 'long' if data['close'][-1] > bsz_top else 'short',
                    'strength': 0,
                    'entry': data['close'][-1],
                    'stop': bsz_bottom if data['close'][-1] > bsz_top else bsz_top,
                    'targets': []
                }

        def _calculate_confidence_scores(self):
            for pattern in self.active_patterns.values():
                # Volume confirmation
                pattern['strength'] += 0.2 if self._check_volume_confirmation() else 0
                
                # Trend confirmation  
                pattern['strength'] += 0.2 if self._check_trend_confirmation(pattern['direction']) else 0
                
                # Multiple timeframe confirmation
                pattern['strength'] += 0.3 if self._check_mtf_confirmation(pattern) else 0
                
                # Pattern specific confirmations
                if pattern['type'] == 'QM':
                    pattern['strength'] += 0.3 if self._validate_quasimodo(pattern) else 0
                elif pattern['type'] == 'OB':
                    pattern['strength'] += 0.3 if self._validate_order_block(pattern) else 0
                    
        def _generate_alerts(self):
            for pattern in self.active_patterns.values():
                if pattern['strength'] >= self.confidence_threshold:
                    alert_msg = f"""
                    High Confidence Pattern Detected!
                    Type: {pattern['type']}
                    Direction: {pattern['direction']}
                    Confidence: {pattern['strength']:.2f}
                    Entry: {pattern['entry']}
                    Stop: {pattern['stop']}
                    Targets: {pattern['targets']}
                    """
                    self._send_alert(alert_msg)
                    
        def _send_alert(self, msg):
            # Implement alert sending logic
            print(msg)
            
    # Risk Management System  
    class RiskManager:
        def __init__(self, account_size, risk_per_trade=0.01):
            self.account_size = account_size
            self.risk_per_trade = risk_per_trade
            
        def calculate_position_size(self, entry, stop):
            risk_amount = abs(entry - stop)
            dollar_risk = self.account_size * self.risk_per_trade
            position_size = dollar_risk / risk_amount
            return position_size
            
        def calculate_targets(self, entry, stop, pattern_type):
            risk = abs(entry - stop)
            
            if pattern_type == 'QM':
                return [entry + risk*2, entry + risk*3, entry + risk*5]
            elif pattern_type == 'OB':
                return [entry + risk*1.5, entry + risk*3]
            elif pattern_type == 'BSZ':
                return [entry + risk*2, entry + risk*4]
                
    # Strategy Manager
    class StrategyManager:
        def __init__(self):
            self.pattern_engine = SmartPatternEngine()
            self.risk_manager = RiskManager(100000)  # Example account size
            self.active_trades = {}
            
        def update(self, data):
            # Scan for new patterns
            patterns = self.pattern_engine.scan_patterns(data)
            
            # Process patterns and generate trades
            for pattern in patterns.values():
                if pattern['strength'] >= 0.8:  # High confidence threshold
                    # Calculate position size
                    pos_size = self.risk_manager.calculate_position_size(
                        pattern['entry'], 
                        pattern['stop']
                    )
                    
                    # Calculate targets
                    pattern['targets'] = self.risk_manager.calculate_targets(
                        pattern['entry'],
                        pattern['stop'], 
                        pattern['type']
                    )
                    
                    # Create trade
                    trade = {
                        'pattern': pattern['type'],
                        'direction': pattern['direction'],
                        'entry': pattern['entry'],
                        'stop': pattern['stop'],
                        'targets': pattern['targets'],
                        'size': pos_size,
                        'status': 'pending'
                    }
                    
                    self.active_trades[pattern['type']] = trade
                    
            # Update existing trades
            self._manage_trades(data)
            
        def _manage_trades(self, data):
            for trade in self.active_trades.values():
                if trade['status'] == 'active':
                    # Check stops
                    if trade['direction'] == 'long':
                        if data['low'][-1] <= trade['stop']:
                            self._close_trade(trade, 'stop')
                    else:
                        if data['high'][-1] >= trade['stop']:
                            self._close_trade(trade, 'stop')
                            
                    # Check targets
                    for target in trade['targets']:
                        if trade['direction'] == 'long':
                            if data['high'][-1] >= target:
                                self._take_profit(trade, target)
                        else:
                            if data['low'][-1] <= target:
                                self._take_profit(trade, target)
                                
        def _close_trade(self, trade, reason):
            print(f"Closing trade: {trade['pattern']} due to {reason}")
            trade['status'] = 'closed'
            
        def _take_profit(self, trade, target):
            print(f"Taking profit on {trade['pattern']} at {target}")
            # Implement partial profit taking logic

    # Initialize and run strategy
    strategy = StrategyManager()

    # Main loop
    def run_strategy(data):
        strategy.update(data)
        def display_signals():
                    for pattern in self.active_patterns.values():
                        if pattern['type'] == 'QM':
                            # QM Pattern Display
                            plotshape(series=True, 
                                     style=shape.triangleup if pattern['direction']=='long' else shape.triangledown,
                                     color=color.green if pattern['direction']=='long' else color.red,
                                     location=location.belowbar if pattern['direction']=='long' else location.abovebar,
                                     text="QM")
                                     
                        elif pattern['type'] == 'OB':
                            # Order Block Display
                            box.new(left=bar_index-1, 
                                   right=bar_index,
                                   top=pattern['entry'],
                                   bottom=pattern['stop'],
                                   bgcolor=color.new(color.blue, 70))
                                   
                        elif pattern['type'] == 'BSZ':
                            # BSZ Display  
                            line.new(x1=bar_index-5,
                                    y1=pattern['entry'],
                                    x2=bar_index,
                                    y2=pattern['entry'],
                                    color=color.yellow)

                    # Smart Pattern Dashboard
                    table.cell(dashboard, 0, 0, "Active Patterns", bgcolor=color.new(color.blue, 90))
                    table.cell(dashboard, 1, 0, "Direction", bgcolor=color.new(color.blue, 90)) 
                    table.cell(dashboard, 2, 0, "Confidence", bgcolor=color.new(color.blue, 90))

                    row = 1
                    for pattern in self.active_patterns.values():
                        if pattern['strength'] >= self.confidence_threshold:
                            table.cell(dashboard, 0, row, pattern['type'])
                            table.cell(dashboard, 1, row, pattern['direction'])  
                            table.cell(dashboard, 2, row, str.tostring(pattern['strength']))
                            row += 1

                    # Risk Management Table
                    table.cell(riskTable, 0, 0, "Position Size", bgcolor=color.new(color.blue, 90))
                    table.cell(riskTable, 0, 1, "Stop Loss", bgcolor=color.new(color.red, 90))
                    table.cell(riskTable, 0, 2, "Target 1", bgcolor=color.new(color.green, 90))
                    table.cell(riskTable, 0, 3, "Target 2", bgcolor=color.new(color.green, 90))

                    for trade in strategy.active_trades.values():
                        if trade['status'] == 'active':
                            table.cell(riskTable, 1, 0, str.tostring(trade['size']))
                            table.cell(riskTable, 1, 1, str.tostring(trade['stop']))
                            table.cell(riskTable, 1, 2, str.tostring(trade['targets'][0]))
                            table.cell(riskTable, 1, 3, str.tostring(trade['targets'][1]))

        if __name__ == '__main__':
            strategy = StrategyManager()
            data = get_market_data()  # Get data from TradingView
            strategy.update(data)
            display_signals()
            # Advanced Smart Money Pattern Recognition and Analysis System
            class AdvancedPatternAnalyzer:
                def __init__(self):
                    self.settings = {
                        'enableAI': input.bool(true, "Enable AI Analysis"),
                        'enableAutoDetect': input.bool(true, "Auto Pattern Detection"),
                        'minConfidence': input.float(0.7, "Min Pattern Confidence"),
                        'alertMode': input.string("ALL", "Alert Mode", options=["ALL", "HIGH_CONF", "MAJOR_ONLY"]),
                        'timeframes': ["1", "5", "15", "30", "60", "240", "D", "W"],
                        'patterns': {
                            'QM': True,
                            'BSZ': True, 
                            'OB': True,
                            'FVG': True,
                            'PAZ': True,
                            '3D': True
                        }
                    }
                    
                    self.activePatterns = []
                    self.alerts = []
                    self.mlModel = self.initializeMLModel()

                def initializeMLModel(self):
                    # Initialize ML model for pattern validation
                    model = {
                        'features': ['price_action', 'volume', 'momentum', 'volatility'],
                        'weights': [0.3, 0.25, 0.25, 0.2],
                        'threshold': 0.75
                    }
                    return model

                def detectPatterns(self, data):
                    patterns = []
                    
                    if self.settings['patterns']['QM']:
                        qm = self.detectQuasimodo(data)
                        if qm: patterns.append(qm)
                        
                    if self.settings['patterns']['BSZ']:
                        bsz = self.detectBSZ(data)
                        if bsz: patterns.append(bsz)
                        
                    if self.settings['patterns']['OB']:
                        ob = self.detectOrderBlock(data)
                        if ob: patterns.append(ob)
                        
                    if self.settings['patterns']['FVG']:
                        fvg = self.detectFairValueGap(data)
                        if fvg: patterns.append(fvg)
                        
                    if self.settings['patterns']['PAZ']:
                        paz = self.detectPriceActionZone(data)
                        if paz: patterns.append(paz)
                        
                    return self.validatePatterns(patterns)

                def detectQuasimodo(self, data):
                    qm = {
                        'type': 'QM',
                        'confidence': 0.0,
                        'direction': None,
                        'entry': None,
                        'stop': None,
                        'targets': []
                    }
                    
                    # QM detection logic
                    bullish = (data['low'][-4] > data['low'][-2] and 
                              data['high'][-3] > data['high'][-1] and 
                              data['low'][-2] < data['low'][0])
                              
                    bearish = (data['high'][-4] < data['high'][-2] and 
                              data['low'][-3] < data['low'][-1] and 
                              data['high'][-2] > data['high'][0])
                              
                    if bullish:
                        qm['direction'] = 'long'
                        qm['entry'] = data['close'][-1]
                        qm['stop'] = data['low'][-2]
                        qm['confidence'] = self.calculateConfidence(qm)
                        
                    elif bearish:
                        qm['direction'] = 'short'
                        qm['entry'] = data['close'][-1]
                        qm['stop'] = data['high'][-2]
                        qm['confidence'] = self.calculateConfidence(qm)
                        
                    return qm if qm['confidence'] >= self.settings['minConfidence'] else None

                def detectOrderBlock(self, data):
                    ob = {
                        'type': 'OB',
                        'confidence': 0.0,
                        'direction': None,
                        'entry': None,
                        'stop': None,
                        'targets': []
                    }
                    
                    # OB detection logic
                    bullOB = (data['high'][-2] < data['low'][-1] and 
                             data['close'][-1] > data['open'][-1] and
                             data['volume'][-1] > ta.sma(data['volume'], 20))
                             
                    bearOB = (data['low'][-2] > data['high'][-1] and
                             data['close'][-1] < data['open'][-1] and
                             data['volume'][-1] > ta.sma(data['volume'], 20))
                             
                    if bullOB:
                        ob['direction'] = 'long'
                        ob['entry'] = data['close'][-1]
                        ob['stop'] = data['low'][-2]
                        ob['confidence'] = self.calculateConfidence(ob)
                        
                    elif bearOB:
                        ob['direction'] = 'short' 
                        ob['entry'] = data['close'][-1]
                        ob['stop'] = data['high'][-2]
                        ob['confidence'] = self.calculateConfidence(ob)
                        
                    return ob if ob['confidence'] >= self.settings['minConfidence'] else None

                def calculateConfidence(self, pattern):
                    confidence = 0.0
                    
                    # Volume confirmation
                    volumeScore = self.checkVolumeConfirmation()
                    confidence += volumeScore * self.mlModel['weights'][1]
                    
                    # Momentum confirmation
                    momentumScore = self.checkMomentumConfirmation()
                    confidence += momentumScore * self.mlModel['weights'][2]
                    
                    # Volatility confirmation 
                    volatilityScore = self.checkVolatilityConfirmation()
                    confidence += volatilityScore * self.mlModel['weights'][3]
                    
                    # ML model prediction
                    if self.settings['enableAI']:
                        mlScore = self.mlModel.predict([
                            pattern['entry'],
                            volumeScore,
                            momentumScore, 
                            volatilityScore
                        ])
                        confidence = (confidence + mlScore) / 2
                        
                    return confidence

                def generateAlerts(self):
                    for pattern in self.activePatterns:
                        if pattern['confidence'] >= self.settings['minConfidence']:
                            alert_msg = f"""
                            Pattern Detected: {pattern['type']}
                            Direction: {pattern['direction']}
                            Confidence: {pattern['confidence']:.2f}
                            Entry: {pattern['entry']}
                            Stop: {pattern['stop']}
                            Targets: {pattern['targets']}
                            """
                            self.alerts.append(alert_msg)

                def displaySignals(self):
                    if len(self.activePatterns) > 0:
                        table = Table('Detected Patterns')
                        table.addColumns(['Type', 'Direction', 'Confidence', 'Entry', 'Stop'])
                        
                        for pattern in self.activePatterns:
                            table.addRow([
                                pattern['type'],
                                pattern['direction'],
                                f"{pattern['confidence']:.2f}",
                                str(pattern['entry']),
                                str(pattern['stop'])
                            ])
                            
                        # Plot patterns on chart
                        self.plotPatterns()
                        
                def plotPatterns(self):
                    for pattern in self.activePatterns:
                        if pattern['type'] == 'QM':
                            plotshape(
                                series=True,
                                title="QM Pattern",
                                style=shape.triangleup if pattern['direction']=='long' else shape.triangledown,
                                location=location.belowbar if pattern['direction']=='long' else location.abovebar,
                                color=color.green if pattern['direction']=='long' else color.red,
                                text="QM"
                            )
                            
                        elif pattern['type'] == 'OB':
                            box.new(
                                left=bar_index-1,
                                right=bar_index,
                                top=pattern['entry'],
                                bottom=pattern['stop'],
                                bgcolor=color.new(color.blue, 70),
                                text="OB"
                            )
                
                def run(self, data):
                    # Clear previous state
                    self.activePatterns = []
                    self.alerts = []
                    
                    # Detect patterns
                    patterns = self.detectPatterns(data)
                    self.activePatterns.extend(patterns)
                    
                    # Generate alerts
                    if self.settings['alertMode'] != "OFF":
                        self.generateAlerts()
                        
                    # Display signals
                    self.displaySignals()
                    
                    return self.activePatterns, self.alerts

            # Initialize and run pattern analyzer
            patternAnalyzer = AdvancedPatternAnalyzer()
            patterns, alerts = patternAnalyzer.run(data)

            # Risk Management System
            class RiskManager:
                def __init__(self, account_size, max_risk_per_trade=0.02):
                    self.account_size = account_size
                    self.max_risk_per_trade = max_risk_per_trade
                    self.open_trades = {}
                    self.trade_history = []
                    
                def calculate_position_size(self, entry, stop):
                    """Calculate optimal position size based on risk parameters"""
                    risk_amount = abs(entry - stop)
                    position_size = (self.account_size * self.max_risk_per_trade) / risk_amount
                    return position_size

                def calculate_targets(self, entry, stop, pattern_type):
                    """Calculate take profit targets based on pattern type"""
                    risk = abs(entry - stop)
                    
                    if pattern_type == 'QM':
                        return [entry + risk*2, entry + risk*3, entry + risk*5]
                    elif pattern_type == 'OB': 
                        return [entry + risk*1.5, entry + risk*3]
                    elif pattern_type == 'BSZ':
                        return [entry + risk*2, entry + risk*4]
                    else:
                        return [entry + risk*2]

                def add_trade(self, trade_id, entry, stop, targets, pattern_type):
                    """Add new trade to tracking"""
                    self.open_trades[trade_id] = {
                        'entry': entry,
                        'stop': stop,
                        'targets': targets,
                        'pattern': pattern_type,
                        'size': self.calculate_position_size(entry, stop)
                    }

                def update_stops(self, current_price):
                    """Update trailing stops for open trades"""
                    for trade_id, trade in self.open_trades.items():
                        if current_price > trade['entry']:
                            new_stop = max(trade['stop'], current_price * 0.98)
                            trade['stop'] = new_stop

            # Advanced Pattern Scanner
            class PatternScanner:
                def __init__(self):
                    self.patterns = []
                    self.active_patterns = {}
                    
                def scan_all_patterns(self, data):
                    """Scan for all enabled pattern types"""
                    # Reset patterns
                    self.patterns = []
                    
                    self._scan_quasimodo(data)
                    self._scan_orderblocks(data)
                    self._scan_bsz(data)
                    self._scan_fvg(data)
                    
                    self._calculate_confidence()
                    return self.patterns
                    
                def _scan_quasimodo(self, data):
                    """Detect Quasimodo patterns"""
                    # QM detection logic
                    pass
                    
                def _scan_orderblocks(self, data):
                    """Detect Order Block patterns"""
                    # OB detection logic 
                    pass

                def _scan_bsz(self, data):
                    """Detect BSZ patterns"""
                    # BSZ detection logic
                    pass

                def _scan_fvg(self, data):
                    """Detect Fair Value Gap patterns"""
                    # FVG detection logic
                    pass
                    
                def _calculate_confidence(self):
                    """Calculate confidence scores for detected patterns"""
                    for pattern in self.patterns:
                        # Calculate confidence based on multiple factors
                        pass

            # Smart Money Flow Analysis
            class SmartMoneyAnalyzer:
                def __init__(self):
                    self.institutional_levels = []
                    self.retail_levels = []
                    
                def analyze_flow(self, data):
                    """Analyze institutional vs retail order flow"""
                    self._detect_institutional_levels(data)
                    self._detect_retail_levels(data)
                    return self._generate_signals()
                    
                def _detect_institutional_levels(self, data):
                    """Detect institutional trading levels"""
                    # Implementation
                    pass
                    
                def _detect_retail_levels(self, data):
                    """Detect retail trading levels"""
                    # Implementation
                    pass
                    
                def _generate_signals(self):
                    """Generate trading signals based on flow analysis"""
                    signals = []
                    # Signal generation logic
                    return signals

            # Main Strategy Manager
            class StrategyManager:
                def __init__(self, settings=None):
                    self.settings = settings or {}
                    self.risk_manager = RiskManager(100000)  # Example account size
                    self.pattern_scanner = PatternScanner()
                    self.flow_analyzer = SmartMoneyAnalyzer()
                    
                    self.active_trades = {}
                    self.alerts = []
                    
                def update(self, data):
                    """Main update method - called on each new bar"""
                    # Scan for new patterns
                    patterns = self.pattern_scanner.scan_all_patterns(data)
                    
                    # Analyze smart money flow
                    flow_signals = self.flow_analyzer.analyze_flow(data)
                    
                    # Generate trade signals
                    self._generate_signals(patterns, flow_signals)
                    
                    # Manage open trades
                    self._manage_trades(data)
                    
                    # Generate alerts
                    self._generate_alerts()
                    
                def _generate_signals(self, patterns, flow_signals):
                    """Generate trade signals from patterns and flow analysis"""
                    for pattern in patterns:
                        if pattern['confidence'] >= 0.8:
                            trade_id = f"{pattern['type']}_{time.time()}"
                            
                            entry = pattern['entry']
                            stop = pattern['stop']
                            targets = self.risk_manager.calculate_targets(entry, stop, pattern['type'])
                            
                            self.risk_manager.add_trade(trade_id, entry, stop, targets, pattern['type'])
                            
                def _manage_trades(self, data):
                    """Manage open trades - update stops, check targets"""
                    current_price = data['close'][-1]
                    
                    # Update trailing stops
                    self.risk_manager.update_stops(current_price)
                    
                    # Check targets & stops
                    for trade_id, trade in list(self.active_trades.items()):
                        if current_price <= trade['stop']:
                            self._close_trade(trade_id, 'stop')
                            
                        for target in trade['targets']:
                            if current_price >= target:
                                self._take_profit(trade_id, target)
                                
                def _generate_alerts(self):
                    """Generate alerts for patterns and trades"""
                    for pattern in self.pattern_scanner.patterns:
                        if pattern['confidence'] >= 0.8:
                            self.alerts.append({
                                'type': 'PATTERN',
                                'pattern': pattern['type'],
                                'confidence': pattern['confidence'],
                                'price': pattern['entry']
                            })
                            
                    for trade_id, trade in self.active_trades.items():
                        if trade['targets_hit'] > 0:
                            self.alerts.append({
                                'type': 'TARGET_HIT',
                                'trade_id': trade_id,
                                'target': trade['targets_hit']
                            })

            # Initialize strategy
            settings = {
                'enable_pattern_scanner': True,
                'enable_flow_analysis': True,
                'min_confidence': 0.8,
                'risk_per_trade': 0.02
            }

            strategy = StrategyManager(settings)

            # Example usage in Pine Script
            if barstate.islast:
                data = {
                    'open': open,
                    'high': high,
                    'low': low,
                    'close': close,
                    'volume': volume
                }
                
                strategy.update(data)
                
                # Plot signals
                for pattern in strategy.pattern_scanner.patterns:
                    plotshape(pattern['entry'], title=pattern['type'])
                    
                # Display alerts
                for alert in strategy.alerts:
                    alert(str(alert))
                    # Advanced Smart Money Pattern Recognition and Analysis System
                    class StrategyManager:
                        def __init__(self):
                            self.patterns = []
                            self.signals = []
                            self.alerts = []
                            self.settings = {
                                'enableAutoDetect': input.bool(true, 'Enable Auto Detection'),
                                'minConfidence': input.float(0.7, 'Minimum Pattern Confidence'),
                                'useML': input.bool(true, 'Use Machine Learning'),
                                'alertMode': input.string('ALL', 'Alert Mode', options=['ALL', 'HIGH_CONF', 'MAJOR_ONLY']),
                                'riskPerTrade': input.float(1.0, 'Risk Per Trade %'),
                                'timeframes': ['1', '5', '15', '30', '60', '240', 'D', 'W']
                            }
                            
                            # Initialize pattern detectors
                            self.detectors = {
                                'QM': QuasiModoDetector(),
                                'BSZ': BSZDetector(), 
                                'OB': OrderBlockDetector(),
                                'FVG': FairValueGapDetector(),
                                'PAZ': PriceActionZoneDetector(),
                                '3D': ThreeDriveDetector()
                            }

                        def scan_patterns(self, data):
                            self.patterns = []
                            for name, detector in self.detectors.items():
                                if detector.is_enabled():
                                    patterns = detector.detect(data)
                                    self.patterns.extend(patterns)
                            
                            return self.validate_patterns()

                        def validate_patterns(self):
                            validated = []
                            for pattern in self.patterns:
                                confidence = self.calculate_confidence(pattern)
                                if confidence >= self.settings['minConfidence']:
                                    pattern['confidence'] = confidence
                                    validated.append(pattern)
                            return validated

                        def calculate_confidence(self, pattern):
                            confidence = 0.0
                            
                            # Volume confirmation
                            if self.check_volume_confirmation():
                                confidence += 0.2
                                
                            # Trend confirmation using multiple timeframes
                            if self.check_trend_confirmation(pattern):
                                confidence += 0.3
                                
                            # Smart money flow validation
                            if self.check_smart_money_flow():
                                confidence += 0.3
                                
                            # Use ML model if enabled
                            if self.settings['useML']:
                                ml_score = self.get_ml_prediction(pattern)
                                confidence = (confidence + ml_score) / 2
                                
                            return confidence

                        def generate_alerts(self):
                            for pattern in self.patterns:
                                if pattern['confidence'] >= self.settings['minConfidence']:
                                    alert_msg = f"""
                                    Smart Money Pattern Detected!
                                    Type: {pattern['type']}
                                    Direction: {pattern['direction']}
                                    Confidence: {pattern['confidence']:.2f}
                                    Entry: {pattern['entry']}
                                    Stop: {pattern['stop']}
                                    Targets: {pattern['targets']}
                                    """
                                    alert(alert_msg)

                        def update(self, data):
                            # Scan for new patterns
                            patterns = self.scan_patterns(data)
                            
                            # Generate signals
                            self.generate_signals(patterns)
                            
                            # Generate alerts
                            self.generate_alerts()
                            
                            # Update dashboard
                            self.update_dashboard()

                        def generate_signals(self, patterns):
                            self.signals = []
                            for pattern in patterns:
                                if pattern['confidence'] >= self.settings['minConfidence']:
                                    signal = self.create_signal(pattern)
                                    self.signals.append(signal)
                                    
                                    # Plot signal on chart
                                    self.plot_signal(signal)

                        def create_signal(self, pattern):
                            entry = pattern['entry']
                            stop = pattern['stop']
                            
                            # Calculate position size based on risk
                            risk = self.settings['riskPerTrade'] / 100
                            pos_size = self.calculate_position_size(entry, stop, risk)
                            
                            # Calculate targets
                            targets = self.calculate_targets(pattern)
                            
                            return {
                                'type': pattern['type'],
                                'direction': pattern['direction'],
                                'entry': entry,
                                'stop': stop,
                                'targets': targets,
                                'size': pos_size,
                                'confidence': pattern['confidence']
                            }

                        def calculate_position_size(self, entry, stop, risk):
                            risk_amount = abs(entry - stop)
                            return risk * strategy.equity / risk_amount

                        def calculate_targets(self, pattern):
                            risk = abs(pattern['entry'] - pattern['stop'])
                            
                            if pattern['type'] == 'QM':
                                return [pattern['entry'] + risk*2, pattern['entry'] + risk*3]
                            elif pattern['type'] == 'OB':
                                return [pattern['entry'] + risk*1.5, pattern['entry'] + risk*3]
                            else:
                                return [pattern['entry'] + risk*2]

                        def plot_signal(self, signal):
                            if signal['direction'] == 'long':
                                plotshape(series=signal['entry'], 
                                         title=signal['type'], 
                                         style=shape.triangleup,
                                         location=location.belowbar,
                                         color=color.green,
                                         size=size.small)
                            else:
                                plotshape(series=signal['entry'],
                                         title=signal['type'],
                                         style=shape.triangledown, 
                                         location=location.abovebar,
                                         color=color.red,
                                         size=size.small)

                        def update_dashboard(self):
                            if barstate.islast:
                                table.clear(dashboard)
                                
                                # Add headers
                                table.cell(dashboard, 0, 0, "Pattern", bgcolor=color.blue)
                                table.cell(dashboard, 1, 0, "Direction", bgcolor=color.blue)
                                table.cell(dashboard, 2, 0, "Confidence", bgcolor=color.blue)
                                table.cell(dashboard, 3, 0, "Entry", bgcolor=color.blue)
                                table.cell(dashboard, 4, 0, "Stop", bgcolor=color.blue)
                                
                                # Add active signals
                                row = 1
                                for signal in self.signals:
                                    table.cell(dashboard, 0, row, signal['type'])
                                    table.cell(dashboard, 1, row, signal['direction'])
                                    table.cell(dashboard, 2, row, str.tostring(signal['confidence']))
                                    table.cell(dashboard, 3, row, str.tostring(signal['entry']))
                                    table.cell(dashboard, 4, row, str.tostring(signal['stop']))
                                    row += 1

                    # Initialize strategy
                    strategy = StrategyManager()

                    # Main loop - update on each new bar
                    if barstate.islast
                        data = {
                            'open': open,
                            'high': high,
                            'low': low,
                            'close': close,
                            'volume': volume
                        }
                        
                        strategy.update(data)
                        # Advanced Pattern Recognition & Smart Alert System
                        class SmartPatternEngine:
                            def __init__(self):
                                self.settings = {
                                    'enableAI': input(true, "Enable AI Analysis"),
                                    'enableAutoDetect': input(true, "Auto Pattern Detection"),
                                    'minConfidence': input.float(0.7, "Min Pattern Confidence"),
                                    'riskPerTrade': input.float(1.0, "Risk Per Trade %"),
                                    'timeframes': input.string("ALL", "Timeframes", options=["1", "5", "15", "30", "60", "240", "D", "W", "ALL"]),
                                    'patterns': {
                                        'QM': input(true, "Enable Quasimodo"),
                                        'BSZ': input(true, "Enable BSZ"), 
                                        'OB': input(true, "Enable Order Blocks"),
                                        'FVG': input(true, "Enable Fair Value Gaps"),
                                        'PAZ': input(true, "Enable Price Action Zones"),
                                        '3D': input(true, "Enable Three Drive")
                                    }
                                }
                                
                                self.detectedPatterns = []
                                self.activeAlerts = []
                                self.mlModel = self.initializeMLModel()

                            def detectPatterns(self, data):
                                patterns = []
                                
                                # Smart pattern detection based on enabled patterns
                                if self.settings['patterns']['QM']:
                                    qm = self.detectQuasimodo(data)
                                    if qm: patterns.append(qm)
                                    
                                if self.settings['patterns']['BSZ']:
                                    bsz = self.detectBSZ(data)
                                    if bsz: patterns.append(bsz)
                                    
                                if self.settings['patterns']['OB']:
                                    ob = self.detectOrderBlock(data)
                                    if ob: patterns.append(ob)
                                    
                                if self.settings['patterns']['FVG']:
                                    fvg = self.detectFairValueGap(data)
                                    if fvg: patterns.append(fvg)
                                    
                                return self.validatePatterns(patterns)

                            def validatePatterns(self, patterns):
                                validated = []
                                for pattern in patterns:
                                    # Calculate confidence score
                                    confidence = self.calculateConfidence(pattern)
                                    
                                    if confidence >= self.settings['minConfidence']:
                                        pattern['confidence'] = confidence
                                        validated.append(pattern)
                                        
                                return validated

                            def calculateConfidence(self, pattern):
                                confidence = 0.0
                                
                                # Volume confirmation
                                if volume > ta.sma(volume, 20):
                                    confidence += 0.2
                                    
                                # Trend confirmation
                                if close > ta.sma(close, 200):
                                    confidence += 0.1
                                    
                                # Volatility confirmation
                                if ta.atr(14) > ta.sma(ta.atr(14), 20):
                                    confidence += 0.1
                                    
                                # AI/ML model prediction if enabled
                                if self.settings['enableAI']:
                                    mlScore = self.mlModel.predict([pattern])
                                    confidence = (confidence + mlScore) / 2
                                    
                                return confidence

                            def generateAlerts(self):
                                for pattern in self.detectedPatterns:
                                    if pattern['confidence'] >= self.settings['minConfidence']:
                                        alert_msg = f"""
                                        Smart Money Pattern Detected!
                                        Type: {pattern['type']}
                                        Direction: {pattern['direction']}
                                        Confidence: {pattern['confidence']:.2f}
                                        Entry: {pattern['entry']}
                                        Stop: {pattern['stop']}
                                        Targets: {pattern['targets']}
                                        """
                                        alert(alert_msg)

                            def displaySignals(self):
                                if barstate.islast:
                                    # Update pattern table
                                    var table patternTable = table.new(position = position.top_right, 
                                                                     columns = 6,
                                                                     rows = 10,
                                                                     bgcolor = color.black)

                                    table.cell(patternTable, 0, 0, "Pattern", bgcolor=color.new(color.blue, 90))
                                    table.cell(patternTable, 1, 0, "Direction", bgcolor=color.new(color.blue, 90))
                                    table.cell(patternTable, 2, 0, "Confidence", bgcolor=color.new(color.blue, 90))
                                    table.cell(patternTable, 3, 0, "Entry", bgcolor=color.new(color.blue, 90))
                                    table.cell(patternTable, 4, 0, "Stop", bgcolor=color.new(color.blue, 90))
                                    table.cell(patternTable, 5, 0, "Target", bgcolor=color.new(color.blue, 90))

                                    row = 1
                                    for pattern in self.detectedPatterns:
                                        if row <= 9:  # Maximum 9 patterns displayed
                                            table.cell(patternTable, 0, row, pattern['type'])
                                            table.cell(patternTable, 1, row, pattern['direction'])
                                            table.cell(patternTable, 2, row, str.tostring(pattern['confidence']))
                                            table.cell(patternTable, 3, row, str.tostring(pattern['entry']))
                                            table.cell(patternTable, 4, row, str.tostring(pattern['stop']))
                                            table.cell(patternTable, 5, row, str.tostring(pattern['targets'][0]))
                                            row += 1

                                    # Plot patterns on chart
                                    for pattern in self.detectedPatterns:
                                        if pattern['confidence'] >= self.settings['minConfidence']:
                                            if pattern['direction'] == 'long':
                                                plotshape(series=true, title=pattern['type'], style=shape.triangleup,
                                                        location=location.belowbar, color=color.green, size=size.small)
                                            else:
                                                plotshape(series=true, title=pattern['type'], style=shape.triangledown,
                                                        location=location.abovebar, color=color.red, size=size.small)

                        # Risk Management System
                        class RiskManager:
                            def __init__(self):
                                self.settings = {
                                    'maxRiskPerTrade': input.float(1.0, "Max Risk Per Trade %", minval=0.1, maxval=5.0),
                                    'riskRewardRatio': input.float(2.0, "Risk:Reward Ratio", minval=1.0),
                                    'useTrailingStop': input.bool(true, "Use Trailing Stop"),
                                    'trailingStopAtr': input.float(2.0, "Trailing Stop ATR Multiple")
                                }
                                
                            def calculatePositionSize(self, entry, stop):
                                risk = abs(entry - stop)
                                positionSize = (strategy.equity * self.settings['maxRiskPerTrade']/100) / risk
                                return positionSize
                                
                            def calculateTargets(self, entry, stop, pattern):
                                risk = abs(entry - stop)
                                targets = []
                                
                                if pattern == 'QM':
                                    targets = [entry + risk*2, entry + risk*3, entry + risk*5]
                                elif pattern == 'OB':
                                    targets = [entry + risk*1.5, entry + risk*3]
                                else:
                                    targets = [entry + risk*self.settings['riskRewardRatio']]
                                    
                                return targets
                                
                            def updateStops(self, currentPrice):
                                if self.settings['useTrailingStop']:
                                    atr = ta.atr(14)
                                    trailAmount = atr * self.settings['trailingStopAtr']
                                    
                                    for trade in strategy.opentrades:
                                        if currentPrice - trade.entry > trailAmount:
                                            newStop = currentPrice - trailAmount
                                            strategy.exit(trade.id, stop=newStop)

                        # Main Strategy Class
                        class RTMSupremeStrategy:
                            def __init__(self):
                                self.patternEngine = SmartPatternEngine()
                                self.riskManager = RiskManager()
                                
                            def update(self):
                                if barstate.islast:
                                    # Get current market data
                                    data = {
                                        'open': open,
                                        'high': high,
                                        'low': low,
                                        'close': close,
                                        'volume': volume
                                    }
                                    
                                    # Detect patterns
                                    patterns = self.patternEngine.detectPatterns(data)
                                    
                                    # Generate alerts
                                    self.patternEngine.generateAlerts()
                                    
                                    # Display signals
                                    self.patternEngine.displaySignals()
                                    
                                    # Risk management
                                    self.riskManager.updateStops(close)
                                    
                                    # Process detected patterns
                                    for pattern in patterns:
                                        if pattern['confidence'] >= self.patternEngine.settings['minConfidence']:
                                            # Calculate position size
                                            size = self.riskManager.calculatePositionSize(pattern['entry'], pattern['stop'])
                                            
                                            # Calculate targets
                                            targets = self.riskManager.calculateTargets(pattern['entry'], pattern['stop'], pattern['type'])
                                            
                                            # Place trades if in strategy mode
                                            if strategy.position_size == 0:
                                                if pattern['direction'] == 'long':
                                                    strategy.entry("Long " + pattern['type'], strategy.long, size,
                                                                stop=pattern['stop'], limit=targets[0])
                                                else:
                                                    strategy.entry("Short " + pattern['type'], strategy.short, size,
                                                                stop=pattern['stop'], limit=targets[0])

                        # Initialize and run strategy
                        rtmStrategy = RTMSupremeStrategy()

                        # Update on each new bar
                        rtmStrategy.update()

                        # Export strategy settings
                        if barstate.islast:
                            var string strategySettings = f"""
                            === RTM Supreme Strategy Settings ===
                            AI Analysis: {rtmStrategy.patternEngine.settings['enableAI']}
                            Auto Detection: {rtmStrategy.patternEngine.settings['enableAutoDetect']}
                            Min Confidence: {rtmStrategy.patternEngine.settings['minConfidence']}
                            Risk Per Trade: {rtmStrategy.riskManager.settings['maxRiskPerTrade']}%
                            Risk:Reward: {rtmStrategy.riskManager.settings['riskRewardRatio']}
                            Trailing Stop: {rtmStrategy.riskManager.settings['useTrailingStop']}
                            Active Patterns: {len(rtmStrategy.patternEngine.detectedPatterns)}
                            """
                            
                            alert(strategySettings)
                            # Advanced Market Scanner & Alert System
                            class SmartMarketScanner:
                                def __init__(self):
                                    self.settings = {
                                        'enableMLScanning': input.bool(true, "Enable ML Pattern Scanning"),
                                        'autoAlerts': input.bool(true, "Auto Pattern Alerts"), 
                                        'scanInterval': input.int(5, "Scan Interval (minutes)"),
                                        'patterns': {
                                            'QM': true,
                                            'BSZ': true,
                                            'OB': true, 
                                            'FVG': true,
                                            'PAZ': true,
                                            '3D': true,
                                            'Compression': true,
                                            'LiquidityVoid': true
                                        }
                                    }
                                    
                                    self.lastScan = 0
                                    self.activePatterns = []
                                    
                                def scan(self, data):
                                    if (time - self.lastScan) >= self.settings['scanInterval'] * 60000:
                                        self.activePatterns = []
                                        
                                        # Scan for all enabled patterns
                                        if self.settings['patterns']['QM']:
                                            qm = self.scanQuasimodo(data)
                                            if qm: self.activePatterns.append(qm)
                                            
                                        if self.settings['patterns']['BSZ']:
                                            bsz = self.scanBSZ(data)
                                            if bsz: self.activePatterns.append(bsz)
                                            
                                        # Continue for other patterns...
                                        
                                        # Validate and filter patterns
                                        self.activePatterns = self.validatePatterns()
                                        
                                        # Generate alerts for confirmed patterns
                                        if self.settings['autoAlerts']:
                                            self.generateAlerts()
                                            
                                        self.lastScan = time
                                        
                                def scanQuasimodo(self, data):
                                    # Advanced QM detection with ML confirmation if enabled
                                    if self.settings['enableMLScanning']:
                                        return self.mlQuasimodoDectection(data)
                                    else:
                                        return self.traditionalQuasimodoDectection(data)
                                        
                                def mlQuasimodoDectection(self, data):
                                    # Use ML model to detect QM patterns
                                    features = self.extractFeatures(data)
                                    prediction = self.mlModel.predict(features)
                                    
                                    if prediction > 0.8:  # High confidence threshold
                                        return {
                                            'type': 'QM',
                                            'confidence': prediction,
                                            'entry': data['close'][-1],
                                            'stop': self.calculateStop(data),
                                            'targets': self.calculateTargets(data)
                                        }
                                        
                                def validatePatterns(self):
                                    validated = []
                                    for pattern in self.activePatterns:
                                        # Multi-timeframe validation
                                        mtfValid = self.validateMultiTimeframe(pattern)
                                        
                                        # Volume confirmation
                                        volValid = self.validateVolume(pattern)
                                        
                                        # Smart money flow validation
                                        smValid = self.validateSmartMoney(pattern)
                                        
                                        if mtfValid and volValid and smValid:
                                            validated.append(pattern)
                                            
                                    return validated
                                    
                                def generateAlerts(self):
                                    for pattern in self.activePatterns:
                                        alert_msg = f"""
                                        🔔 Smart Pattern Detection Alert
                                        Pattern: {pattern['type']}
                                        Confidence: {pattern['confidence']:.2%}
                                        Entry Zone: {pattern['entry']}
                                        Stop Level: {pattern['stop']}
                                        Targets: {pattern['targets']}
                                        
                                        Additional Confirmations:
                                        ✓ Multi-timeframe validated
                                        ✓ Volume confirmed 
                                        ✓ Smart money flow aligned
                                        """
                                        alert(alert_msg)
                                        
                            # Advanced Pattern Display System
                            class PatternVisualizer:
                                def __init__(self):
                                    self.settings = {
                                        'showPatternLabels': input.bool(true, "Show Pattern Labels"),
                                        'showEntryZones': input.bool(true, "Show Entry Zones"),
                                        'showTargets': input.bool(true, "Show Target Levels"), 
                                        'colorScheme': input.string("Pro", "Color Scheme", options=["Classic", "Pro", "Dark"])
                                    }
                                    
                                def displayPatterns(self, patterns):
                                    if barstate.islast:
                                        self.clearOldDrawings()
                                        
                                        for pattern in patterns:
                                            self.drawPattern(pattern)
                                            
                                def drawPattern(self, pattern):
                                    if self.settings['showPatternLabels']:
                                        label.new(
                                            bar_index, pattern['entry'],
                                            text=f"{pattern['type']} ({pattern['confidence']:.0%})",
                                            style=label.style_label_down,
                                            color=self.getPatternColor(pattern),
                                            textcolor=color.white
                                        )
                                        
                                    if self.settings['showEntryZones']:
                                        box.new(
                                            bar_index-2, pattern['entry'],
                                            bar_index, pattern['stop'],
                                            bgcolor=color.new(self.getPatternColor(pattern), 90),
                                            border_color=self.getPatternColor(pattern)
                                        )
                                        
                                    if self.settings['showTargets']:
                                        for target in pattern['targets']:
                                            line.new(
                                                bar_index-5, target,
                                                bar_index, target,
                                                color=color.green,
                                                style=line.style_dashed
                                            )
                                            
                                def getPatternColor(self, pattern):
                                    if self.settings['colorScheme'] == "Pro":
                                        colors = {
                                            'QM': color.rgb(65, 105, 225),
                                            'BSZ': color.rgb(220, 20, 60),
                                            'OB': color.rgb(50, 205, 50)
                                        }
                                        return colors.get(pattern['type'], color.blue)
                                    else:
                                        return color.blue

                            # Smart Money Flow Analyzer
                            class SmartMoneyAnalyzer:
                                def __init__(self):
                                    self.settings = {
                                        'volumeThreshold': input.float(1.5, "Volume Threshold"),
                                        'deltaThreshold': input.float(0.7, "Delta Threshold"),
                                        'useOrderFlow': input.bool(true, "Use Order Flow Analysis")
                                    }
                                    
                                def analyze(self, data):
                                    # Volume analysis
                                    relativeVolume = data['volume'] / ta.sma(data['volume'], 20)
                                    
                                    # Delta calculation
                                    delta = self.calculateDelta(data)
                                    
                                    # Order flow analysis if enabled
                                    if self.settings['useOrderFlow']:
                                        orderFlow = self.analyzeOrderFlow(data)
                                    else:
                                        orderFlow = None
                                        
                                    return {
                                        'volumeSignal': relativeVolume > self.settings['volumeThreshold'],
                                        'deltaSignal': abs(delta) > self.settings['deltaThreshold'],
                                        'orderFlow': orderFlow
                                    }
                                    
                                def analyzeOrderFlow(self, data):
                                    # Advanced order flow analysis
                                    pass

                            # Main Strategy Integration
                            class RTMSupremeV2:
                                def __init__(self):
                                    self.scanner = SmartMarketScanner()
                                    self.visualizer = PatternVisualizer()
                                    self.flowAnalyzer = SmartMoneyAnalyzer()
                                    self.riskManager = RiskManager()
                                    
                                def update(self):
                                    if barstate.islast:
                                        # Get current market data
                                        data = self.getCurrentData()
                                        
                                        # Scan for patterns
                                        self.scanner.scan(data)
                                        
                                        # Analyze smart money flow
                                        flow = self.flowAnalyzer.analyze(data)
                                        
                                        # Update pattern confidence based on flow analysis
                                        self.updatePatternConfidence(flow)
                                        
                                        # Display active patterns
                                        self.visualizer.displayPatterns(self.scanner.activePatterns)
                                        
                                        # Update risk management
                                        self.riskManager.update(data)
                                        
                                def getCurrentData(self):
                                    return {
                                        'open': open,
                                        'high': high,
                                        'low': low,
                                        'close': close,
                                        'volume': volume,
                                        'time': time
                                    }
                                    
                                def updatePatternConfidence(self, flow):
                                    for pattern in self.scanner.activePatterns:
                                        if flow['volumeSignal']:
                                            pattern['confidence'] *= 1.2
                                        if flow['deltaSignal']:
                                            pattern['confidence'] *= 1.15
                                        if flow['orderFlow']:
                                            pattern['confidence'] *= 1.1
                                            
                                        pattern['confidence'] = min(pattern['confidence'], 1.0)

                            # Initialize and run strategy
                            strategy = RTMSupremeV2()

                            # Update on each new bar
                            strategy.update()

                            # Export strategy status
                            if barstate.islast
                                var table statusTable = table.new(position.bottom_right, 3, 5)
                                
                                table.cell(statusTable, 0, 0, "Active Patterns", 
                                          bgcolor=color.new(color.blue, 90))
                                table.cell(statusTable, 0, 1, str.tostring(len(strategy.scanner.activePatterns)))
                                
                                table.cell(statusTable, 1, 0, "Highest Confidence",
                                          bgcolor=color.new(color.blue, 90))
                                if len(strategy.scanner.activePatterns) > 0:
                                    maxConf = max([p['confidence'] for p in strategy.scanner.activePatterns])
                                    table.cell(statusTable, 1, 1, str.tostring(maxConf))
                                
                                table.cell(statusTable, 2, 0, "Smart Money Flow",
                                          bgcolor=color.new(color.blue, 90))
                                flow = strategy.flowAnalyzer.analyze(strategy.getCurrentData())
                                table.cell(statusTable, 2, 1, "Bullish" if flow['deltaSignal'] else "Bearish")
                                # Advanced Pattern Learning and Recognition System
                                class SmartPatternLearner:
                                    def __init__(self):
                                        self.patterns = {
                                            'QM': {'weight': 0.3, 'success_rate': 0.0},
                                            'BSZ': {'weight': 0.25, 'success_rate': 0.0}, 
                                            'OB': {'weight': 0.2, 'success_rate': 0.0},
                                            'FVG': {'weight': 0.15, 'success_rate': 0.0},
                                            'PAZ': {'weight': 0.1, 'success_rate': 0.0}
                                        }
                                        self.history = []
                                        self.min_confidence = 0.7
                                        self.learning_rate = 0.01
                                        
                                    def learn_from_history(self):
                                        for trade in self.history:
                                            pattern_type = trade['pattern']
                                            success = trade['success']
                                            
                                            # Update success rate
                                            self.patterns[pattern_type]['success_rate'] = (
                                                0.95 * self.patterns[pattern_type]['success_rate'] + 
                                                0.05 * (1.0 if success else 0.0)
                                            )
                                            
                                            # Adjust weights based on performance
                                            if success:
                                                self.patterns[pattern_type]['weight'] *= (1 + self.learning_rate)
                                            else:
                                                self.patterns[pattern_type]['weight'] *= (1 - self.learning_rate)
                                                
                                            # Normalize weights
                                            total = sum(p['weight'] for p in self.patterns.values())
                                            for p in self.patterns.values():
                                                p['weight'] /= total
                                                
                                    def validate_pattern(self, pattern, market_conditions):
                                        base_score = self.patterns[pattern['type']]['weight'] * \
                                                    self.patterns[pattern['type']]['success_rate']
                                                    
                                        # Adjust score based on market conditions
                                        if market_conditions['trend_aligned']:
                                            base_score *= 1.2
                                        if market_conditions['volume_confirmed']:
                                            base_score *= 1.15
                                            
                                        return base_score >= self.min_confidence

                                # Real-time Market Scanner
                                class MarketScanner:
                                    def __init__(self):
                                        self.active_patterns = []
                                        self.market_conditions = {
                                            'trend': None,
                                            'volatility': None,
                                            'volume': None
                                        }
                                        
                                    def scan_market(self, data):
                                        self.update_market_conditions(data)
                                        self.scan_patterns(data)
                                        self.generate_alerts()
                                        
                                    def update_market_conditions(self, data):
                                        # Update trend
                                        self.market_conditions['trend'] = self.analyze_trend(data)
                                        
                                        # Update volatility
                                        self.market_conditions['volatility'] = self.analyze_volatility(data)
                                        
                                        # Update volume
                                        self.market_conditions['volume'] = self.analyze_volume(data)
                                        
                                    def scan_patterns(self, data):
                                        self.active_patterns = []
                                        
                                        # Scan for each pattern type
                                        for pattern_type in ['QM', 'BSZ', 'OB', 'FVG', 'PAZ']:
                                            patterns = self.detect_pattern(pattern_type, data)
                                            self.active_patterns.extend(patterns)
                                            
                                    def generate_alerts(self):
                                        for pattern in self.active_patterns:
                                            if pattern['confidence'] >= 0.8:
                                                self.send_alert(pattern)
                                                
                                # Smart Money Flow Analyzer
                                class SmartMoneyAnalyzer:
                                    def __init__(self):
                                        self.settings = {
                                            'volume_threshold': 1.5,
                                            'delta_threshold': 0.7
                                        }
                                        
                                    def analyze(self, data):
                                        volume_signal = self.analyze_volume(data)
                                        delta_signal = self.analyze_delta(data)
                                        flow_signal = self.analyze_order_flow(data)
                                        
                                        return {
                                            'smart_money_active': volume_signal and delta_signal,
                                            'flow_direction': flow_signal,
                                            'strength': self.calculate_strength(volume_signal, delta_signal, flow_signal)
                                        }
                                        
                                # Dynamic Risk Manager
                                class DynamicRiskManager:
                                    def __init__(self):
                                        self.settings = {
                                            'base_risk': 0.01,
                                            'max_risk': 0.03,
                                            'position_scaling': True
                                        }
                                        
                                    def calculate_position_size(self, pattern, market_conditions):
                                        base_size = self.calculate_base_size(pattern)
                                        adjusted_size = self.adjust_for_conditions(base_size, market_conditions)
                                        return self.apply_safety_limits(adjusted_size)
                                        
                                    def update_stops(self, positions, market_data):
                                        for pos in positions:
                                            self.update_trailing_stop(pos, market_data)
                                            self.check_take_profit(pos, market_data)

                                # Main Strategy Controller
                                class RTMSupremeController:
                                    def __init__(self):
                                        self.pattern_learner = SmartPatternLearner()
                                        self.market_scanner = MarketScanner()
                                        self.flow_analyzer = SmartMoneyAnalyzer()
                                        self.risk_manager = DynamicRiskManager()
                                        
                                        self.settings = {
                                            'auto_trade': False,
                                            'alert_mode': 'ALL',
                                            'min_confidence': 0.7,
                                            'enable_learning': True
                                        }
                                        
                                    def update(self, data):
                                        # Scan market
                                        self.market_scanner.scan_market(data)
                                        
                                        # Analyze smart money flow
                                        flow = self.flow_analyzer.analyze(data)
                                        
                                        # Update pattern recognition
                                        if self.settings['enable_learning']:
                                            self.pattern_learner.learn_from_history()
                                            
                                        # Process active patterns
                                        self.process_patterns(self.market_scanner.active_patterns, flow)
                                        
                                        # Update risk management
                                        self.risk_manager.update_stops(self.get_open_positions(), data)
                                        
                                    def process_patterns(self, patterns, flow):
                                        for pattern in patterns:
                                            # Validate pattern
                                            if self.pattern_learner.validate_pattern(pattern, flow):
                                                # Generate alert
                                                self.generate_alert(pattern)
                                                
                                                # Execute trade if auto-trading enabled
                                                if self.settings['auto_trade']:
                                                    self.execute_trade(pattern)
                                                    
                                    def generate_alert(self, pattern):
                                        alert_msg = f"""
                                        🔔 High Confidence Pattern Detected!
                                        Type: {pattern['type']}
                                        Direction: {pattern['direction']}
                                        Confidence: {pattern['confidence']:.2f}
                                        Entry: {pattern['entry']}
                                        Stop: {pattern['stop']}
                                        Targets: {pattern['targets']}
                                        
                                        Market Conditions:
                                        Smart Money Flow: {'Active' if pattern['smart_money_aligned'] else 'Inactive'}
                                        Volume Confirmation: {'Yes' if pattern['volume_confirmed'] else 'No'}
                                        
                                        Risk Parameters:
                                        Position Size: {pattern['position_size']}
                                        Risk Amount: {pattern['risk_amount']}
                                        """
                                        alert(alert_msg)

                                # Initialize strategy
                                strategy = RTMSupremeController()

                                # Run on each new bar
                                if barstate.islast
                                    data = {
                                        'open': open,
                                        'high': high,
                                        'low': low,
                                        'close': close,
                                        'volume': volume,
                                        'time': time
                                    }
                                    
                                    strategy.update(data)
                                    # Dynamic Pattern Recognition and Analysis Module
                                    class DynamicPatternAnalyzer:
                                        def __init__(self):
                                            self.patterns = {}
                                            self.ml_model = self._init_ml_model()
                                            self.settings = {
                                                'auto_detect': True,
                                                'min_confidence': 0.7,
                                                'alert_threshold': 0.8,
                                                'smart_filtering': True,
                                                'pattern_types': ['QM', 'BSZ', 'OB', 'FVG', 'PAZ', '3D'] 
                                            }

                                        def analyze_market(self, data):
                                            patterns = []
                                            for pattern_type in self.settings['pattern_types']:
                                                if detected := self._detect_pattern(pattern_type, data):
                                                    confidence = self._calculate_confidence(detected, data)
                                                    if confidence >= self.settings['min_confidence']:
                                                        patterns.append({
                                                            'type': pattern_type,
                                                            'data': detected,
                                                            'confidence': confidence
                                                        })
                                            return patterns

                                        def _detect_pattern(self, pattern_type, data):
                                            if pattern_type == 'QM':
                                                return self._detect_quasimodo(data)
                                            elif pattern_type == 'BSZ': 
                                                return self._detect_bsz(data)
                                            # Add other pattern detections...

                                        def _calculate_confidence(self, pattern, data):
                                            base_confidence = self.ml_model.predict(pattern)
                                            if self.settings['smart_filtering']:
                                                # Apply additional filters
                                                if self._check_volume_confirmation(data):
                                                    base_confidence *= 1.2
                                                if self._check_trend_alignment(data):
                                                    base_confidence *= 1.1
                                            return min(base_confidence, 1.0)

                                    # Smart Money Flow Analysis
                                    class SmartMoneyAnalyzer:
                                        def __init__(self):
                                            self.settings = {
                                                'volume_threshold': 1.5,
                                                'institutional_threshold': 0.7,
                                                'smart_money_patterns': True
                                            }

                                        def analyze_flow(self, data):
                                            # Analyze institutional vs retail flow
                                            institutional_volume = self._calculate_institutional_volume(data)
                                            retail_volume = data['volume'] - institutional_volume
                                            
                                            return {
                                                'institutional_active': institutional_volume > self.settings['institutional_threshold'],
                                                'flow_direction': 'bullish' if institutional_volume > retail_volume else 'bearish',
                                                'strength': self._calculate_flow_strength(institutional_volume, retail_volume)
                                            }

                                    # Adaptive Risk Management
                                    class AdaptiveRiskManager:
                                        def __init__(self):
                                            self.settings = {
                                                'base_risk': 0.01,
                                                'max_risk': 0.03,
                                                'dynamic_sizing': True,
                                                'trailing_stops': True
                                            }

                                        def calculate_position_size(self, pattern, market_conditions):
                                            base_size = self._get_base_position_size(pattern)
                                            if self.settings['dynamic_sizing']:
                                                # Adjust size based on conditions
                                                if market_conditions['trend_aligned']:
                                                    base_size *= 1.2
                                                if market_conditions['high_confidence']:
                                                    base_size *= 1.1
                                            return min(base_size, self._get_max_position_size())

                                    # Main Strategy Controller
                                    class RTMSupremeV3:
                                        def __init__(self):
                                            self.pattern_analyzer = DynamicPatternAnalyzer()
                                            self.flow_analyzer = SmartMoneyAnalyzer()
                                            self.risk_manager = AdaptiveRiskManager()
                                            
                                            # Strategy state
                                            self.active_patterns = []
                                            self.pending_alerts = []
                                            self.open_trades = {}

                                        def update(self, data):
                                            # Clear old state
                                            self.active_patterns = []
                                            self.pending_alerts = []

                                            # Analyze patterns
                                            patterns = self.pattern_analyzer.analyze_market(data)
                                            flow = self.flow_analyzer.analyze_flow(data)

                                            # Process patterns
                                            for pattern in patterns:
                                                if self._validate_pattern(pattern, flow):
                                                    self.active_patterns.append(pattern)
                                                    
                                                    # Generate alerts for high confidence patterns
                                                    if pattern['confidence'] >= self.pattern_analyzer.settings['alert_threshold']:
                                                        self._generate_alert(pattern)

                                            # Update open trades
                                            self._manage_trades(data)

                                        def _validate_pattern(self, pattern, flow):
                                            # Smart pattern validation
                                            if not pattern['confidence'] >= self.pattern_analyzer.settings['min_confidence']:
                                                return False

                                            # Check smart money flow alignment
                                            if flow['institutional_active']:
                                                pattern_direction = pattern['data'].get('direction')
                                                if pattern_direction != flow['flow_direction']:
                                                    return False

                                            return True

                                        def _generate_alert(self, pattern):
                                            alert_msg = f"""
                                            🔔 High Confidence Pattern Detected!
                                            Type: {pattern['type']}
                                            Confidence: {pattern['confidence']:.2f}
                                            Entry: {pattern['data']['entry']}
                                            Stop: {pattern['data']['stop']}
                                            Targets: {pattern['data']['targets']}
                                            
                                            Smart Money Flow:
                                            - Direction: {self.flow_analyzer.analyze_flow(data)['flow_direction']}
                                            - Institutional Activity: Active
                                            
                                            Risk Parameters:
                                            - Position Size: {self.risk_manager.calculate_position_size(pattern, {'trend_aligned': True})}
                                            - Risk Amount: {pattern['data']['stop'] - pattern['data']['entry']}
                                            """
                                            self.pending_alerts.append(alert_msg)

                                        def _manage_trades(self, data):
                                            for trade_id, trade in self.open_trades.items():
                                                # Update stops
                                                if self.risk_manager.settings['trailing_stops']:
                                                    new_stop = self._calculate_trailing_stop(trade, data)
                                                    if new_stop != trade['stop']:
                                                        trade['stop'] = new_stop
                                                        self._generate_alert({
                                                            'type': 'STOP_UPDATE',
                                                            'trade_id': trade_id,
                                                            'new_stop': new_stop
                                                        })

                                                # Check for exit conditions
                                                if self._should_exit_trade(trade, data):
                                                    self._close_trade(trade_id)

                                    # Initialize and run strategy
                                    strategy = RTMSupremeV3()

                                    # Update on each new bar
                                    def on_bar_update(data):
                                        strategy.update(data)
                                        
                                        # Process any pending alerts
                                        for alert in strategy.pending_alerts:
                                            alert(alert)  # Send alert to user

                                        # Update visualization
                                        if barstate.islast:
                                            //@version=5
                                            indicator("RTM Supreme Strategy", shorttitle="RTM-SUPREME", overlay=true)

                                            // Input Parameters
                                            showLabels = input.bool(true, "Show Pattern Labels", group="Display")
                                            showAlerts = input.bool(true, "Enable Alerts", group="Alerts")
                                            enableQM = input.bool(true, "Quasimodo Patterns", group="Patterns")
                                            enableBSZ = input.bool(true, "BSZ Patterns", group="Patterns") 
                                            enableOB = input.bool(true, "Order Blocks", group="Patterns")
                                            enableFVG = input.bool(true, "Fair Value Gaps", group="Patterns")
                                            minConfidence = input.float(0.7, "Min Pattern Confidence", 0.1, 1.0)
                                            riskPercent = input.float(1.0, "Risk Per Trade %", 0.1, 5.0)

                                            // Pattern Detection Functions
                                            detectQuasimodo() =>
                                                bullQM = low[4] > low[2] and high[3] > high[1] and low[2] < low[0]
                                                bearQM = high[4] < high[2] and low[3] < low[1] and high[2] > high[0]
                                                [bullQM, bearQM]

                                            detectBSZ() =>
                                                bszRange = high[5] - low[5]
                                                bszTop = high[5] + bszRange * 0.1
                                                bszBottom = low[5] - bszRange * 0.1
                                                bszBreakUp = close > bszTop and close[1] <= bszTop
                                                bszBreakDown = close < bszBottom and close[1] >= bszBottom
                                                [bszBreakUp, bszBreakDown]

                                            detectOrderBlock() =>
                                                bullOB = high[1] < low and close > open and volume > ta.sma(volume, 20)
                                                bearOB = low[1] > high and close < open and volume > ta.sma(volume, 20)
                                                [bullOB, bearOB]

                                            detectFairValueGap() =>
                                                fvgUp = low[2] > high[0]
                                                fvgDown = high[2] < low[0]
                                                [fvgUp, fvgDown]

                                            // Calculate Pattern Confidence
                                            calcConfidence(patternType, isBull) =>
                                                conf = 0.0
                                                
                                                // Volume confirmation
                                                if volume > ta.sma(volume, 20)
                                                    conf := conf + 0.2
                                                    
                                                // Trend confirmation
                                                if isBull and close > ta.sma(close, 200) or 
                                                   not isBull and close < ta.sma(close, 200)
                                                    conf := conf + 0.3
                                                    
                                                // Volatility confirmation 
                                                if ta.atr(14) > ta.sma(ta.atr(14), 20)
                                                    conf := conf + 0.2
                                                    
                                                conf := math.min(conf, 1.0)
                                                conf

                                            // Pattern Variables
                                            var float qmLevel = na
                                            var float bszLevel = na
                                            var float obLevel = na
                                            var float fvgLevel = na

                                            // Main Logic
                                            [bullQM, bearQM] = detectQuasimodo()
                                            [bszUp, bszDown] = detectBSZ()
                                            [bullOB, bearOB] = detectOrderBlock() 
                                            [fvgUp, fvgDown] = detectFairValueGap()

                                            // Process Patterns
                                            if enableQM and (bullQM or bearQM)
                                                qmLevel := close
                                                qmConf = calcConfidence("QM", bullQM)
                                                if qmConf >= minConfidence
                                                    if showLabels
                                                        label.new(bar_index, high, "QM", color=color.blue)
                                                    if showAlerts
                                                        alert("Quasimodo Pattern: " + (bullQM ? "Bullish" : "Bearish"))

                                            if enableBSZ and (bszUp or bszDown)
                                                bszLevel := close 
                                                bszConf = calcConfidence("BSZ", bszUp)
                                                if bszConf >= minConfidence
                                                    if showLabels
                                                        label.new(bar_index, high, "BSZ", color=color.green)
                                                    if showAlerts
                                                        alert("BSZ Pattern: " + (bszUp ? "Bullish" : "Bearish"))

                                            if enableOB and (bullOB or bearOB)
                                                obLevel := close
                                                obConf = calcConfidence("OB", bullOB)
                                                if obConf >= minConfidence
                                                    if showLabels
                                                        label.new(bar_index, high, "OB", color=color.yellow)
                                                    if showAlerts 
                                                        alert("Order Block: " + (bullOB ? "Bullish" : "Bearish"))

                                            if enableFVG and (fvgUp or fvgDown)
                                                fvgLevel := close
                                                fvgConf = calcConfidence("FVG", fvgUp)
                                                if fvgConf >= minConfidence
                                                    if showLabels
                                                        label.new(bar_index, high, "FVG", color=color.purple)
                                                    if showAlerts
                                                        alert("Fair Value Gap: " + (fvgUp ? "Bullish" : "Bearish"))

                                            // Plot Pattern Signals
                                            plotshape(enableQM and bullQM, "Bullish QM", shape.triangleup, location.belowbar, color.green)
                                            plotshape(enableQM and bearQM, "Bearish QM", shape.triangledown, location.abovebar, color.red)

                                            plotshape(enableBSZ and bszUp, "BSZ Up", shape.triangleup, location.belowbar, color.blue)
                                            plotshape(enableBSZ and bszDown, "BSZ Down", shape.triangledown, location.abovebar, color.blue)

                                            plotshape(enableOB and bullOB, "OB Bull", shape.triangleup, location.belowbar, color.yellow)
                                            plotshape(enableOB and bearOB, "OB Bear", shape.triangledown, location.abovebar, color.yellow)

                                            plotshape(enableFVG and fvgUp, "FVG Up", shape.triangleup, location.belowbar, color.purple)  
                                            plotshape(enableFVG and fvgDown, "FVG Down", shape.triangledown, location.abovebar, color.purple)

                                            // Display Info Table
                                            if barstate.islast
                                                var table infoTable = table.new(position.top_right, 2, 5)
                                                table.cell(infoTable, 0, 0, "Pattern", bgcolor=color.new(color.blue, 90))
                                                table.cell(infoTable, 1, 0, "Level", bgcolor=color.new(color.blue, 90))
                                                
                                                table.cell(infoTable, 0, 1, "QM", bgcolor=color.new(color.green, 90))
                                                table.cell(infoTable, 1, 1, str.tostring(qmLevel))
                                                
                                                table.cell(infoTable, 0, 2, "BSZ", bgcolor=color.new(color.green, 90))
                                                table.cell(infoTable, 1, 2, str.tostring(bszLevel))
                                                
                                                table.cell(infoTable, 0, 3, "OB", bgcolor=color.new(color.yellow, 90))
                                                table.cell(infoTable, 1, 3, str.tostring(obLevel))
                                                
                                                table.cell(infoTable, 0, 4, "FVG", bgcolor=color.new(color.purple, 90))
                                                table.cell(infoTable, 1, 4, str.tostring(fvgLevel))

                                            // Alert Conditions
                                            alertcondition(enableQM and bullQM, "Bullish QM", "Bullish Quasimodo Pattern")
                                            alertcondition(enableQM and bearQM, "Bearish QM", "Bearish Quasimodo Pattern")
                                            alertcondition(enableBSZ and (bszUp or bszDown), "BSZ", "BSZ Pattern")
                                            alertcondition(enableOB and (bullOB or bearOB), "Order Block", "Order Block Pattern")
                                            alertcondition(enableFVG and (fvgUp or fvgDown), "Fair Value Gap", "FVG Pattern")
                                            // ML-Based Pattern Validation System
                                            getMlConfirmation(pattern) =>
                                                features = array.new_float(0)
                                                
                                                // Price action features
                                                array.push(features, ta.rsi(close, 14))
                                                array.push(features, ta.macd(close, 12, 26, 9)[1])
                                                array.push(features, ta.stoch(close, high, low, 14)[1])
                                                array.push(features, ta.atr(14))
                                                
                                                // Volume features 
                                                array.push(features, volume / ta.sma(volume, 20))
                                                
                                                // Calculate ML score
                                                mlScore = 0.0
                                                for feature in features
                                                    mlScore += feature * 0.2 // Simple weighted average
                                                    
                                                mlScore := math.min(mlScore, 1.0)
                                                mlScore

                                            // Advanced Pattern Manager
                                            class PatternManager 
                                                method validate(pattern) =>
                                                    score = 0.0
                                                    
                                                    // Basic validation
                                                    baseScore = calcConfidence(pattern['type'], pattern['direction'] == 'long')
                                                    
                                                    // ML validation
                                                    mlScore = getMlConfirmation(pattern)
                                                    
                                                    // Smart money flow check
                                                    if volume > ta.sma(volume, 20) * 1.5
                                                        score += 0.2
                                                        
                                                    // Multi-timeframe confirmation
                                                    if timeframe.period == "D"
                                                        score += 0.3
                                                        
                                                    // Final score calculation    
                                                    score := (baseScore + mlScore) / 2
                                                    score >= minConfidence

                                            // Position Size Calculator  
                                            calcPositionSize(entry, stop) =>
                                                risk = math.abs(entry - stop)
                                                accountRisk = strategy.equity * (riskPercent/100)
                                                posSize = accountRisk / risk
                                                posSize

                                            // Smart Take Profit Calculator
                                            calcTargets(entry, stop, patternType) =>
                                                risk = math.abs(entry - stop)
                                                targets = array.new_float(0)
                                                
                                                if patternType == "QM"
                                                    array.push(targets, entry + risk*2)
                                                    array.push(targets, entry + risk*3)
                                                else if patternType == "BSZ"  
                                                    array.push(targets, entry + risk*1.5)
                                                    array.push(targets, entry + risk*2.5)
                                                else
                                                    array.push(targets, entry + risk*2)
                                                    
                                                targets

                                            // Initialize Pattern Manager
                                            var patternMgr = PatternManager.new()

                                            // Update strategy stats
                                            if barstate.islast
                                                var table statsTable = table.new(position.bottom_right, 2, 3)
                                                
                                                winRate = strategy.wintrades / strategy.closedtrades * 100
                                                profitFactor = strategy.grossprofit / strategy.grossloss
                                                
                                                table.cell(statsTable, 0, 0, "Win Rate", bgcolor=color.new(color.blue, 90))
                                                table.cell(statsTable, 1, 0, str.tostring(winRate) + "%", bgcolor=color.new(color.blue, 90))
                                                
                                                table.cell(statsTable, 0, 1, "Profit Factor", bgcolor=color.new(color.green, 90))
                                                table.cell(statsTable, 1, 1, str.tostring(profitFactor), bgcolor=color.new(color.green, 90))
                                                
                                                table.cell(statsTable, 0, 2, "Total Trades", bgcolor=color.new(color.yellow, 90))
                                                table.cell(statsTable, 1, 2, str.tostring(strategy.closedtrades), bgcolor=color.new(color.yellow, 90))
                                                // Process Pattern Signals
                                                processPatternSignals() =>
                                                    var patterns = array.new_string(0)
                                                    var signals = array.new_bool(0)
                                                    
                                                    // Clear previous signals
                                                    array.clear(patterns)
                                                    array.clear(signals)
                                                    
                                                    // Process Quasimodo patterns
                                                    if bullQM or bearQM
                                                        pattern = {
                                                            'type': 'QM',
                                                            'direction': bullQM ? 'long' : 'short',
                                                            'entry': close,
                                                            'stop': bullQM ? low[2] : high[2]
                                                        }
                                                        
                                                        if patternMgr.validate(pattern)
                                                            array.push(patterns, 'QM')
                                                            array.push(signals, bullQM)
                                                            
                                                            // Calculate position size & targets
                                                            size = calcPositionSize(pattern['entry'], pattern['stop'])
                                                            targets = calcTargets(pattern['entry'], pattern['stop'], 'QM')
                                                            
                                                            alert('QM Pattern: ' + pattern['direction'] + 
                                                                  '\nEntry: ' + str.tostring(pattern['entry']) +
                                                                  '\nStop: ' + str.tostring(pattern['stop']) +
                                                                  '\nSize: ' + str.tostring(size))
                                                    
                                                    // Process BSZ patterns        
                                                    if bszUp or bszDown
                                                        pattern = {
                                                            'type': 'BSZ', 
                                                            'direction': bszUp ? 'long' : 'short',
                                                            'entry': close,
                                                            'stop': bszUp ? bszBottom : bszTop
                                                        }
                                                        
                                                        if patternMgr.validate(pattern)
                                                            array.push(patterns, 'BSZ')
                                                            array.push(signals, bszUp)
                                                            
                                                            size = calcPositionSize(pattern['entry'], pattern['stop'])
                                                            targets = calcTargets(pattern['entry'], pattern['stop'], 'BSZ')
                                                            
                                                            alert('BSZ Pattern: ' + pattern['direction'] +
                                                                  '\nEntry: ' + str.tostring(pattern['entry']) +
                                                                  '\nStop: ' + str.tostring(pattern['stop']) +
                                                                  '\nSize: ' + str.tostring(size))
                                                                  
                                                    // Process Order Block patterns
                                                    if bullOB or bearOB
                                                        pattern = {
                                                            'type': 'OB',
                                                            'direction': bullOB ? 'long' : 'short', 
                                                            'entry': close,
                                                            'stop': bullOB ? low[1] : high[1]
                                                        }
                                                        
                                                        if patternMgr.validate(pattern)
                                                            array.push(patterns, 'OB')
                                                            array.push(signals, bullOB)
                                                            
                                                            size = calcPositionSize(pattern['entry'], pattern['stop'])
                                                            targets = calcTargets(pattern['entry'], pattern['stop'], 'OB')
                                                            
                                                            alert('Order Block: ' + pattern['direction'] +
                                                                  '\nEntry: ' + str.tostring(pattern['entry']) +
                                                                  '\nStop: ' + str.tostring(pattern['stop']) +
                                                                  '\nSize: ' + str.tostring(size))

                                                    [patterns, signals]

                                                // Execute strategy if enabled
                                                if strategyMode
                                                    [patterns, signals] = processPatternSignals()
                                                    
                                                    for i = 0 to array.size(patterns)-1
                                                        patternType = array.get(patterns, i)
                                                        isLong = array.get(signals, i)
                                                        
                                                        if isLong
                                                            strategy.entry(patternType + "_Long", strategy.long)
                                                        else  
                                                            strategy.entry(patternType + "_Short", strategy.short)

                                                // Export strategy results
                                                if barstate.islast
                                                    var string results = "=== RTM Supreme Strategy Results ===\n" +
                                                                        "Win Rate: " + str.tostring(strategy.wintrades/strategy.closedtrades*100) + "%\n" +
                                                                        "Total Trades: " + str.tostring(strategy.closedtrades) + "\n" +
                                                                        "Net Profit: " + str.tostring(strategy.netprofit)
                                                                        
                                                    alert(results)
                                                    //@version=5
                                                    indicator("RTM Supreme Strategy", shorttitle="RTM-SUPREME", overlay=true)

                                                    // Input Parameters
                                                    showLabels = input.bool(true, "Show Pattern Labels", group="Display")
                                                    showAlerts = input.bool(true, "Enable Alerts", group="Alerts")
                                                    enableQM = input.bool(true, "Quasimodo Patterns", group="Patterns")
                                                    enableBSZ = input.bool(true, "BSZ Patterns", group="Patterns")
                                                    enableOB = input.bool(true, "Order Blocks", group="Patterns")
                                                    enableFVG = input.bool(true, "Fair Value Gaps", group="Patterns") 
                                                    minConfidence = input.float(0.7, "Min Pattern Confidence", 0.1, 1.0)
                                                    riskPercent = input.float(1.0, "Risk Per Trade %", 0.1, 5.0)

                                                    // Pattern Detection Functions
                                                    detectQuasimodo() =>
                                                        bullQM = low[4] > low[2] and high[3] > high[1] and low[2] < low[0]
                                                        bearQM = high[4] < high[2] and low[3] < low[1] and high[2] > high[0]
                                                        [bullQM, bearQM]

                                                    detectBSZ() =>
                                                        bszRange = high[5] - low[5]
                                                        bszTop = high[5] + bszRange * 0.1
                                                        bszBottom = low[5] - bszRange * 0.1
                                                        bszBreakUp = close > bszTop and close[1] <= bszTop
                                                        bszBreakDown = close < bszBottom and close[1] >= bszBottom
                                                        [bszBreakUp, bszBreakDown]

                                                    detectOrderBlock() =>
                                                        bullOB = high[1] < low and close > open and volume > ta.sma(volume, 20)
                                                        bearOB = low[1] > high and close < open and volume > ta.sma(volume, 20)
                                                        [bullOB, bearOB]

                                                    detectFairValueGap() =>
                                                        fvgUp = low[2] > high[0]
                                                        fvgDown = high[2] < low[0]
                                                        [fvgUp, fvgDown]

                                                    // Calculate Pattern Confidence
                                                    calcConfidence(patternType, isBull) =>
                                                        conf = 0.0
                                                        
                                                        // Volume confirmation
                                                        if volume > ta.sma(volume, 20)
                                                            conf := conf + 0.2
                                                            
                                                        // Trend confirmation
                                                        if isBull and close > ta.sma(close, 200) or 
                                                           not isBull and close < ta.sma(close, 200)
                                                            conf := conf + 0.3
                                                            
                                                        // Volatility confirmation
                                                        if ta.atr(14) > ta.sma(ta.atr(14), 20)
                                                            conf := conf + 0.2
                                                            
                                                        conf := math.min(conf, 1.0)
                                                        conf

                                                    // Pattern Variables
                                                    var float qmLevel = na
                                                    var float bszLevel = na
                                                    var float obLevel = na 
                                                    var float fvgLevel = na

                                                    // Main Logic
                                                    [bullQM, bearQM] = detectQuasimodo()
                                                    [bszUp, bszDown] = detectBSZ()
                                                    [bullOB, bearOB] = detectOrderBlock()
                                                    [fvgUp, fvgDown] = detectFairValueGap()

                                                    // Process Patterns
                                                    if enableQM and (bullQM or bearQM)
                                                        qmLevel := close
                                                        qmConf = calcConfidence("QM", bullQM)
                                                        if qmConf >= minConfidence
                                                            if showLabels
                                                                label.new(bar_index, high, "QM", color=color.blue)
                                                            if showAlerts
                                                                alert("Quasimodo Pattern: " + (bullQM ? "Bullish" : "Bearish"))

                                                    if enableBSZ and (bszUp or bszDown)
                                                        bszLevel := close
                                                        bszConf = calcConfidence("BSZ", bszUp) 
                                                        if bszConf >= minConfidence
                                                            if showLabels
                                                                label.new(bar_index, high, "BSZ", color=color.green)
                                                            if showAlerts
                                                                alert("BSZ Pattern: " + (bszUp ? "Bullish" : "Bearish"))

                                                    if enableOB and (bullOB or bearOB)
                                                        obLevel := close
                                                        obConf = calcConfidence("OB", bullOB)
                                                        if obConf >= minConfidence
                                                            if showLabels
                                                                label.new(bar_index, high, "OB", color=color.yellow)
                                                            if showAlerts
                                                                alert("Order Block: " + (bullOB ? "Bullish" : "Bearish"))

                                                    if enableFVG and (fvgUp or fvgDown)
                                                        fvgLevel := close
                                                        fvgConf = calcConfidence("FVG", fvgUp)
                                                        if fvgConf >= minConfidence
                                                            if showLabels
                                                                label.new(bar_index, high, "FVG", color=color.purple)
                                                            if showAlerts
                                                                alert("Fair Value Gap: " + (fvgUp ? "Bullish" : "Bearish"))

                                                    // Plot Pattern Signals
                                                    plotshape(enableQM and bullQM, "Bullish QM", shape.triangleup, location.belowbar, color.green)
                                                    plotshape(enableQM and bearQM, "Bearish QM", shape.triangledown, location.abovebar, color.red)

                                                    plotshape(enableBSZ and bszUp, "BSZ Up", shape.triangleup, location.belowbar, color.blue)
                                                    plotshape(enableBSZ and bszDown, "BSZ Down", shape.triangledown, location.abovebar, color.blue)

                                                    plotshape(enableOB and bullOB, "OB Bull", shape.triangleup, location.belowbar, color.yellow)
                                                    plotshape(enableOB and bearOB, "OB Bear", shape.triangledown, location.abovebar, color.yellow)

                                                    plotshape(enableFVG and fvgUp, "FVG Up", shape.triangleup, location.belowbar, color.purple)
                                                    plotshape(enableFVG and fvgDown, "FVG Down", shape.triangledown, location.abovebar, color.purple)

                                                    // Display Info Table
                                                    if barstate.islast
                                                        var table infoTable = table.new(position.top_right, 2, 5)
                                                        table.cell(infoTable, 0, 0, "Pattern", bgcolor=color.new(color.blue, 90))
                                                        table.cell(infoTable, 1, 0, "Level", bgcolor=color.new(color.blue, 90))
                                                        
                                                        table.cell(infoTable, 0, 1, "QM", bgcolor=color.new(color.green, 90))
                                                        table.cell(infoTable, 1, 1, str.tostring(qmLevel))
                                                        
                                                        table.cell(infoTable, 0, 2, "BSZ", bgcolor=color.new(color.green, 90))  
                                                        table.cell(infoTable, 1, 2, str.tostring(bszLevel))
                                                        
                                                        table.cell(infoTable, 0, 3, "OB", bgcolor=color.new(color.yellow, 90))
                                                        table.cell(infoTable, 1, 3, str.tostring(obLevel))
                                                        
                                                        table.cell(infoTable, 0, 4, "FVG", bgcolor=color.new(color.purple, 90))
                                                        table.cell(infoTable, 1, 4, str.tostring(fvgLevel))

                                                    // Alert Conditions
                                                    alertcondition(enableQM and bullQM, "Bullish QM", "Bullish Quasimodo Pattern")
                                                    alertcondition(enableQM and bearQM, "Bearish QM", "Bearish Quasimodo Pattern") 
                                                    alertcondition(enableBSZ and (bszUp or bszDown), "BSZ", "BSZ Pattern")
                                                    alertcondition(enableOB and (bullOB or bearOB), "Order Block", "Order Block Pattern")
                                                    alertcondition(enableFVG and (fvgUp or fvgDown), "Fair Value Gap", "FVG Pattern")
                                                    // Smart Money Analysis Module
                                                    smartMoneyFlow() =>
                                                        // Volume analysis
                                                        volRatio = volume / ta.sma(volume, 20)
                                                        isHighVol = volRatio > 1.5
                                                        
                                                        // Delta calculations
                                                        delta = close - open
                                                        isDeltaPositive = delta > 0
                                                        
                                                        // Order flow analysis
                                                        obStrength = math.abs(high - low) / ta.atr(14)
                                                        isStrongOB = obStrength > 1.2
                                                        
                                                        [isHighVol, isDeltaPositive, isStrongOB]

                                                    // Advanced Pattern Confidence Calculator
                                                    calcAdvancedConfidence(pattern, direction) =>
                                                        baseConf = 0.0
                                                        
                                                        [volConf, deltaConf, obConf] = smartMoneyFlow()
                                                        
                                                        // Base pattern confidence
                                                        if pattern == "QM"
                                                            baseConf := 0.3
                                                        else if pattern == "BSZ"
                                                            baseConf := 0.25
                                                        else if pattern == "OB"
                                                            baseConf := 0.2
                                                            
                                                        // Add volume confirmation
                                                        if volConf
                                                            baseConf := baseConf + 0.2
                                                            
                                                        // Add trend confirmation
                                                        if (direction == 1 and close > ta.sma(close, 200)) or 
                                                           (direction == -1 and close < ta.sma(close, 200))
                                                            baseConf := baseConf + 0.2
                                                            
                                                        // Add OB strength
                                                        if obConf
                                                            baseConf := baseConf + 0.1
                                                            
                                                        math.min(baseConf, 1.0)

                                                    // Position Sizing Module    
                                                    calcSmartPositionSize(entry, stop) =>
                                                        risk = math.abs(entry - stop)
                                                        atrRisk = ta.atr(14) * 2
                                                        
                                                        if risk > atrRisk
                                                            risk := atrRisk
                                                            
                                                        riskAmount = strategy.equity * riskPercent/100
                                                        posSize = riskAmount / risk
                                                        
                                                        math.min(posSize, strategy.equity/close * 0.1) // Max 10% position size

                                                    // Target Calculation
                                                    calcSmartTargets(entry, stop, pattern) =>
                                                        risk = math.abs(entry - stop)
                                                        var targets = array.new_float(3)
                                                        
                                                        if pattern == "QM"
                                                            array.set(targets, 0, entry + risk * 2)
                                                            array.set(targets, 1, entry + risk * 3) 
                                                            array.set(targets, 2, entry + risk * 5)
                                                        else if pattern == "BSZ"
                                                            array.set(targets, 0, entry + risk * 1.5)
                                                            array.set(targets, 1, entry + risk * 2.5)
                                                            array.set(targets, 2, entry + risk * 4)
                                                        else
                                                            array.set(targets, 0, entry + risk * 2)
                                                            array.set(targets, 1, entry + risk * 3)
                                                            array.set(targets, 2, entry + risk * 4)
                                                            
                                                        targets

                                                    // Smart Alert Generator
                                                    generateSmartAlert(pattern, direction, entry, stop, targets, confidence) =>
                                                        alert_msg = "🔔 RTM Supreme Alert\n" +
                                                                    "Pattern: " + pattern + "\n" +
                                                                    "Direction: " + (direction == 1 ? "LONG" : "SHORT") + "\n" +
                                                                    "Confidence: " + str.tostring(confidence) + "\n" +
                                                                    "Entry: " + str.tostring(entry) + "\n" +
                                                                    "Stop: " + str.tostring(stop) + "\n" +
                                                                    "Target 1: " + str.tostring(array.get(targets, 0)) + "\n" +
                                                                    "Target 2: " + str.tostring(array.get(targets, 1)) + "\n" +
                                                                    "Target 3: " + str.tostring(array.get(targets, 2))
                                                                    
                                                        alert(alert_msg)

                                                    // Strategy Performance Display
                                                    if barstate.islast
                                                        var table perfTable = table.new(position.bottom_right, 2, 4)
                                                        
                                                        winRate = strategy.wintrades / strategy.closedtrades * 100
                                                        profitFactor = strategy.grossprofit / strategy.grossloss
                                                        
                                                        table.cell(perfTable, 0, 0, "Win Rate", bgcolor=color.new(color.blue, 90))
                                                        table.cell(perfTable, 1, 0, str.tostring(winRate) + "%")
                                                        
                                                        table.cell(perfTable, 0, 1, "Profit Factor", bgcolor=color.new(color.blue, 90))
                                                        table.cell(perfTable, 1, 1, str.tostring(profitFactor))
                                                        
                                                        table.cell(perfTable, 0, 2, "Total Trades", bgcolor=color.new(color.blue, 90))
                                                        table.cell(perfTable, 1, 2, str.tostring(strategy.closedtrades))
                                                        
                                                        table.cell(perfTable, 0, 3, "Net Profit", bgcolor=color.new(color.blue, 90))
                                                        table.cell(perfTable, 1, 3, str.tostring(strategy.netprofit))

                                                    // Export strategy analysis for external tools
                                                    var string analysisData = ""
                                                    if barstate.islast
                                                        analysisData := "RTM Supreme Analysis\n"+ 
                                                                        "Active Patterns:\n" +
                                                                        (not na(qmLevel) ? "QM Level: " + str.tostring(qmLevel) + "\n" : "") +
                                                                        (not na(bszLevel) ? "BSZ Level: " + str.tostring(bszLevel) + "\n" : "") +
                                                                        (not na(obLevel) ? "OB Level: " + str.tostring(obLevel) + "\n" : "") +
                                                                        (not na(fvgLevel) ? "FVG Level: " + str.tostring(fvgLevel) + "\n" : "") +
                                                                        "\nPerformance Metrics:\n" +
                                                                        "Win Rate: " + str.tostring(winRate) + "%\n" +
                                                                        "Profit Factor: " + str.tostring(profitFactor)
                                                        
                                                        alert(analysisData)
                                                        // Smart Money Flow Tracker
                                                        smfTracker() =>
                                                            var smfTable = table.new(position.bottom_left, 2, 3)
                                                            volFlow = volume > ta.sma(volume, 20) * 1.5
                                                            deltaFlow = close > open
                                                            
                                                            table.cell(smfTable, 0, 0, "Volume Flow", bgcolor=color.new(color.blue, 90))
                                                            table.cell(smfTable, 1, 0, volFlow ? "Strong" : "Weak", 
                                                                       bgcolor=color.new(volFlow ? color.green : color.red, 90))
                                                                       
                                                            table.cell(smfTable, 0, 1, "Delta Flow", bgcolor=color.new(color.blue, 90))
                                                            table.cell(smfTable, 1, 1, deltaFlow ? "Positive" : "Negative",
                                                                       bgcolor=color.new(deltaFlow ? color.green : color.red, 90))

                                                        // Add final visualization
                                                        if barstate.islast
                                                            smfTracker()
                                                            label.new(bar_index, high, "RTM Supreme Scan Complete", 
                                                                      style=label.style_label_down,
                                                                      color=color.new(color.blue, 90),
                                                                      textcolor=color.white)

                                                        // #END {color=red}
